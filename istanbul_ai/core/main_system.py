"""
Main Istanbul Daily Talk AI System - Simplified and Modular
"""

import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from ..core.user_profile import UserProfile, UserType
from ..core.conversation_context import ConversationContext
from ..core.entity_recognizer import IstanbulEntityRecognizer
from ..utils.constants import ConversationTone, DEFAULT_RESPONSES

# Configure logger first
logger = logging.getLogger(__name__)

# Import advanced transportation system
try:
    import sys
    import os
    # Add parent directory to path to access transportation modules
    parent_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    if parent_dir not in sys.path:
        sys.path.append(parent_dir)
    
    from enhanced_transportation_system import TransportationQueryProcessor
    from ml_enhanced_transportation_system import create_ml_enhanced_transportation_system, GPSLocation
    ADVANCED_TRANSPORT_AVAILABLE = True
    logger.info("‚úÖ Advanced transportation system loaded successfully")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Advanced transportation system not available: {e}")
    ADVANCED_TRANSPORT_AVAILABLE = False


class IstanbulDailyTalkAI:
    """
    Simplified Istanbul Daily Talk AI System
    Refactored from monolithic 2915-line file for better maintainability
    """
    
    def __init__(self):
        self.logger = logger
        self.entity_recognizer = IstanbulEntityRecognizer()
        self.user_profiles: Dict[str, UserProfile] = {}
        self.conversation_contexts: Dict[str, ConversationContext] = {}
        
        # Initialize integrations (simplified)
        self._init_integrations()
        
        # Initialize services
        self._init_services()
        
        logger.info("üéâ Enhanced Istanbul Daily Talk AI System initialized (Modular Architecture)")

    def _init_integrations(self):
        """Initialize external integrations"""
        try:
            # Initialize advanced transportation system
            if ADVANCED_TRANSPORT_AVAILABLE:
                self.transport_processor = TransportationQueryProcessor()
                self.ml_transport_system = create_ml_enhanced_transportation_system()
                logger.info("üöá Advanced transportation system with IBB API initialized")
            else:
                self.transport_processor = None
                self.ml_transport_system = None
                
            # Try to load external integrations
            self._load_events_integration()
            self._load_route_integration()
            self._load_deep_learning()
            logger.info("‚úÖ External integrations loaded successfully")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Some integrations not available: {e}")
            self._init_fallback_systems()

    def _load_events_integration(self):
        """Load events integration"""
        try:
            from monthly_events_scheduler import MonthlyEventsScheduler
            self.events_scheduler = MonthlyEventsScheduler()
            self.events_available = True
            logger.info("üé≠ Events integration loaded")
        except ImportError:
            self.events_available = False
            logger.warning("‚ö†Ô∏è Events integration not available")

    def _load_route_integration(self):
        """Load route integration"""
        try:
            from services.route_maker import IstanbulRoutemaker
            self.route_maker = IstanbulRoutemaker()
            self.routing_available = True
            logger.info("üó∫Ô∏è Route integration loaded")
        except ImportError:
            self.routing_available = False
            logger.warning("‚ö†Ô∏è Route integration not available")

    def _load_deep_learning(self):
        """Load deep learning components"""
        try:
            from deep_learning_enhanced_ai import DeepLearningEnhancedAI
            self.deep_learning_ai = DeepLearningEnhancedAI()
            self.deep_learning_available = True
            logger.info("üß† Deep learning integration loaded")
        except ImportError:
            self.deep_learning_available = False
            logger.warning("‚ö†Ô∏è Deep learning not available")

    def _init_fallback_systems(self):
        """Initialize fallback systems when integrations are not available"""
        self.events_available = False
        self.routing_available = False
        self.deep_learning_available = False

    def _init_services(self):
        """Initialize advanced services"""
        try:
            from ..services.intelligent_location_detector import IntelligentLocationDetector
            from ..services.gps_location_service import GPSLocationService
            from ..services.neighborhood_guide_service import NeighborhoodGuideService
            
            self.location_detector = IntelligentLocationDetector()
            self.gps_service = GPSLocationService()
            self.neighborhood_guide = NeighborhoodGuideService()
            self.advanced_services_available = True
            logger.info("‚úÖ Advanced location and neighborhood guide services loaded")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Advanced services not available: {e}")
            self.location_detector = None
            self.neighborhood_guide = None
            self.gps_service = None
            self.advanced_services_available = False
        
        # Initialize multi-intent query handler
        try:
            from multi_intent_query_handler import MultiIntentQueryHandler
            self.multi_intent_handler = MultiIntentQueryHandler()
            self.multi_intent_available = True
            logger.info("‚úÖ Multi-Intent Query Handler loaded")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Multi-Intent Query Handler not available: {e}")
            self.multi_intent_handler = None
            self.multi_intent_available = False

    def get_or_create_user_profile(self, user_id: str) -> UserProfile:
        """Get or create user profile"""
        if user_id not in self.user_profiles:
            self.user_profiles[user_id] = UserProfile(user_id=user_id)
            logger.info(f"Created new user profile for {user_id}")
        return self.user_profiles[user_id]

    def get_or_create_conversation_context(self, session_id: str, user_profile: UserProfile) -> ConversationContext:
        """Get or create conversation context"""
        if session_id not in self.conversation_contexts:
            self.conversation_contexts[session_id] = ConversationContext(
                session_id=session_id,
                user_profile=user_profile
            )
        return self.conversation_contexts[session_id]

    def process_message(self, user_input: str, user_id: str) -> str:
        """
        Main message processing method - enhanced with multi-intent support
        """
        try:
            # Get user profile and context
            user_profile = self.get_or_create_user_profile(user_id)
            session_id = f"session_{user_id}"
            context = self.get_or_create_conversation_context(session_id, user_profile)
            
            # Use multi-intent handler if available for enhanced processing
            if self.multi_intent_available and self.multi_intent_handler:
                response = self._process_with_multi_intent(user_input, user_profile, context)
            else:
                # Fallback to traditional processing
                response = self._process_traditional(user_input, user_profile, context)
            
            # Add to conversation history
            context.add_interaction(user_input, response, "processed")
            
            return response
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            return self._generate_fallback_response(user_input)

    def _determine_primary_intent(self, intent_signals: Dict[str, float]) -> str:
        """Determine primary intent from signals with improved logic"""
        if not intent_signals:
            return "general_info"
        
        # Return intent with highest confidence, but with minimum threshold
        max_intent, max_confidence = max(intent_signals.items(), key=lambda x: x[1])
        
        # Only return intent if confidence is above threshold
        if max_confidence >= 0.3:
            return max_intent
        else:
            return "general_info"

    def _process_by_intent(self, user_input: str, intent: str, entities: Dict, user_profile: UserProfile) -> str:
        """Process message by detected intent - legacy method"""
        return self._process_by_intent_enhanced(user_input, intent, entities, user_profile)

    def _process_by_intent_enhanced(self, user_input: str, intent: str, entities: Dict, user_profile: UserProfile) -> str:
        """Process message by detected intent with enhanced routing"""
        
        # Get context for enhanced processing
        session_id = f"session_{user_profile.user_id}"
        context = self.get_or_create_conversation_context(session_id, user_profile)
        
        # Check for neighborhood/district-specific queries first (Priority #1)
        user_input_lower = user_input.lower()
        matched_districts = []
        
        if self.neighborhood_guide:
            matched_districts = self.neighborhood_guide.find_districts_by_keywords(user_input)
            
            # Enhanced neighborhood detection keywords
            neighborhood_keywords = [
                'neighborhood', 'district', 'area', 'guide', 'vibe', 'atmosphere', 'character',
                'compare', 'comparison', 'vs', 'versus', 'which is better',
                'complete guide', 'comprehensive guide', 'everything about',
                'besiktas', 'be≈üikta≈ü', 'kadikoy', 'kadƒ±k√∂y', 'sultanahmet', 
                'sisli', '≈üi≈üli', 'uskudar', '√ºsk√ºdar', 'fatih', 'sariyer', 'sarƒ±yer'
            ]
            
            # Multi-intent neighborhood queries (e.g., "restaurants in Kadƒ±k√∂y", "nightlife in Be≈üikta≈ü")
            district_context_keywords = [
                f"{query_type} in" for query_type in ['restaurants', 'nightlife', 'attractions', 'shopping', 'food', 'bars', 'clubs', 'sights']
            ]
            
            has_neighborhood_context = (
                any(word in user_input_lower for word in neighborhood_keywords) or
                any(phrase in user_input_lower for phrase in district_context_keywords) or
                matched_districts or
                # Check for specific district mentions with context
                any(f"in {district}" in user_input_lower for district in ['kadikoy', 'kadƒ±k√∂y', 'besiktas', 'be≈üikta≈ü', 'sultanahmet', 'sisli', '≈üi≈üli', 'uskudar', '√ºsk√ºdar', 'fatih', 'sariyer', 'sarƒ±yer'])
            )
            
            if has_neighborhood_context:
                return self._handle_neighborhood_guide_query(user_input, entities, user_profile, context)
        
        # Map different intent formats to consistent handlers
        elif intent in ["restaurant", "restaurant_query"] or self._is_restaurant_query(user_input):
            return self._handle_restaurant_query(user_input, entities, user_profile, context)
        elif intent in ["events", "events_query"] or any(word in user_input.lower() for word in ['event', 'happening', 'show', 'performance', 'exhibition']):
            return self._handle_events_query(user_input, entities, user_profile)
        elif intent in ["transportation", "transportation_query"] or any(word in user_input.lower() for word in ['transport', 'metro', 'bus', 'taxi', 'how to get']):
            return self._handle_transportation_query(user_input, entities, user_profile)
        elif intent in ["attractions", "attraction_query"] or any(word in user_input.lower() for word in ['visit', 'see', 'attraction', 'museum', 'palace']):
            return self._handle_attractions_query(user_input, entities, user_profile)
        else:
            return self._handle_general_query(user_input, entities, user_profile)

    def _handle_restaurant_query(self, user_input: str, entities: Dict, user_profile: UserProfile, context: Optional['ConversationContext'] = None) -> str:
        """Handle restaurant-related queries with enhanced recommendations and location detection"""
        
        # Get location information - either from query or intelligent detection
        districts = entities.get('districts', [])
        detected_location = None
        
        if districts:
            detected_location = districts[0]
        elif context:
            # Use intelligent location detection if no explicit location in query
            detected_location = self._detect_user_location(user_input, user_profile, context)
        
        cuisines = entities.get('cuisines', [])
        dietary = entities.get('dietary', [])
        budget = entities.get('budget', [])
        time_refs = entities.get('time', [])
        
        # Check for specific food items and complex requirements
        query_lower = user_input.lower()
        
        # Handle specific food/drink queries
        if 'turkish coffee' in query_lower or ('coffee' in query_lower and 'dessert' in query_lower):
            return self._handle_coffee_dessert_query(user_input, entities)
        elif 'pide' in query_lower:
            return self._handle_pide_query(user_input, entities)
        elif 'street food' in query_lower:
            return self._handle_street_food_query(user_input, entities)
        elif 'gluten-free' in query_lower or 'gluten free' in query_lower:
            return self._handle_gluten_free_query(user_input, entities)
        elif 'lactose-free' in query_lower or 'lactose free' in query_lower or 'dairy intolerance' in query_lower:
            return self._handle_lactose_free_query(user_input, entities)
        elif 'meyhane' in query_lower or ('traditional' in query_lower and 'music' in query_lower):
            return self._handle_meyhane_query(user_input, entities)
        elif 'waterfront' in query_lower and 'fish' in query_lower:
            return self._handle_waterfront_fish_query(user_input, entities)
        elif any(word in query_lower for word in ['diabetic', 'sugar-free', 'pregnant', 'pregnancy', 'wheelchair', 'accessible']):
            return self._handle_complex_dietary_query(user_input, entities)
        elif 'lactose-free' in query_lower or 'lactose free' in query_lower:
            return self._handle_lactose_free_query(user_input, entities)
        
        response = "üçΩÔ∏è **Restaurant Recommendations for Istanbul**\n\n"
        
        # Enhanced location-specific recommendations with context awareness
        if detected_location:
            # Get detection method for more personalized messaging
            detection_method = context.get_context('location_detection_method') if context else 'unknown'
            
            if detection_method == 'explicit_query':
                response += f"üó∫Ô∏è **Best restaurants in {detected_location} (as requested):**\n\n"
            elif detection_method == 'proximity_inference':
                response += f"üó∫Ô∏è **Nearby restaurants in {detected_location} area:**\n\n"
            elif detection_method == 'user_profile':
                response += f"üó∫Ô∏è **Restaurants near your location in {detected_location}:**\n\n"
            elif detection_method == 'context_memory':
                response += f"üó∫Ô∏è **Restaurants in {detected_location} (from our conversation):**\n\n"
            elif detection_method == 'conversation_history':
                response += f"üó∫Ô∏è **Restaurants in {detected_location} (based on your recent interests):**\n\n"
            elif detection_method == 'favorite_neighborhood':
                response += f"üó∫Ô∏è **Restaurants in your favorite area, {detected_location}:**\n\n"
            else:
                response += f"üó∫Ô∏è **Best restaurants in {detected_location}:**\n\n"
                
            district_name = detected_location
            
            if detected_location.lower() == 'sultanahmet':
                restaurants = [
                    ("Pandeli", "Historic Ottoman restaurant above Spice Bazaar", "Traditional Turkish", "$$"),
                    ("Hamdi Restaurant", "Famous for ƒ∞skender kebab with Bosphorus view", "Turkish Grill", "$$"),
                    ("Seven Hills Restaurant", "Rooftop dining with Blue Mosque view", "Turkish/International", "$$$")
                ]
            elif district_name.lower() in ['beyoglu', 'galata']:
                restaurants = [
                    ("Mikla", "Award-winning modern Turkish cuisine", "Fine Dining", "$$$$"),
                    ("Karakoy Lokantasi", "Ottoman-inspired elegant dining", "Turkish", "$$$"),
                    ("Zubeyir Ocakbasi", "Authentic grill house loved by locals", "Turkish Grill", "$$")
                ]
            elif district_name.lower() == 'kadikoy':
                restaurants = [
                    ("Ciya Sofrasi", "Traditional Anatolian cuisine", "Turkish Regional", "$$"),
                    ("Kanaat Lokantasi", "Historic neighborhood restaurant", "Turkish Home Cooking", "$"),
                    ("Sur Balik", "Fresh seafood on Asian side", "Seafood", "$$$")
                ]
            elif district_name.lower() == 'taksim':
                restaurants = [
                    ("360 Istanbul", "Panoramic city views with international menu", "International", "$$$"),
                    ("Masa Restaurant", "Contemporary Turkish in stylish setting", "Modern Turkish", "$$$"),
                    ("Leb-i Derya", "Trendy rooftop with Bosphorus views", "Mediterranean", "$$$")
                ]
            elif district_name.lower() == 'besiktas':
                restaurants = [
                    ("Tugra Restaurant", "Ottoman palace cuisine", "Ottoman", "$$$$"),
                    ("Feriye Palace", "Historic waterfront dining", "Turkish", "$$$"),
                    ("Poseidon", "Fresh seafood by the Bosphorus", "Seafood", "$$$")
                ]
            elif district_name.lower() == 'sisli':
                restaurants = [
                    ("Spago", "International fine dining", "International", "$$$$"),
                    ("Vogue Restaurant", "Stylish dining with city views", "International", "$$$"),
                    ("Local Brasserie", "French-Turkish fusion", "Fusion", "$$$")
                ]
            elif district_name.lower() == 'nisantasi':
                restaurants = [
                    ("Nicole Restaurant", "Michelin-starred fine dining", "Fine Dining", "$$$$$"),
                    ("Seasons Restaurant", "Elegant Four Seasons dining", "International", "$$$$"),
                    ("House Cafe", "Trendy cafe with good food", "Cafe/International", "$$$")
                ]
            elif district_name.lower() == 'eminonu':
                restaurants = [
                    ("Pandeli", "Historic restaurant in Spice Bazaar", "Ottoman", "$$"),
                    ("Hamdi Restaurant", "Famous for Adana kebab", "Turkish Grill", "$$"),
                    ("Balƒ±k Pazarƒ±", "Fresh fish market restaurants", "Seafood", "$$")
                ]
            elif district_name.lower() == 'levent':
                restaurants = [
                    ("Sunset Grill & Bar", "International with Bosphorus view", "International", "$$$"),
                    ("Ulus 29", "Upscale dining with panoramic views", "International", "$$$$"),
                    ("Park Fora", "Business district favorite", "Turkish/International", "$$$")
                ]
            else:
                # Provide realistic restaurant names for other districts
                restaurants = [
                    ("Lokanta Maya", "Contemporary Turkish cuisine", "Modern Turkish", "$$$"),
                    ("√áiya Sofrasƒ±", "Regional Anatolian specialties", "Turkish Regional", "$$"),
                    ("Pandeli", "Historic Ottoman dining", "Traditional Turkish", "$$")
                ]
        else:
            response += "üåü **Top Istanbul Restaurant Picks:**\n\n"
            restaurants = [
                ("Nusr-Et Steakhouse", "Famous Turkish steakhouse", "Steakhouse", "$$$$"),
                ("Balikci Sabahattin", "Historic seafood institution", "Seafood", "$$$"),
                ("Develi", "Legendary kebab restaurant", "Turkish Grill", "$$"),
                ("Sunset Grill & Bar", "International cuisine with Bosphorus view", "International", "$$$")
            ]
        
        # Display restaurants
        for i, (name, desc, cuisine, price) in enumerate(restaurants, 1):
            response += f"**{i}. {name}** {price}\n"
            response += f"   {desc}\n"
            response += f"   üçΩÔ∏è Cuisine: {cuisine}\n\n"
        
        # Add specific filters and handle special requirements
        filter_notes = []
        special_requirements = []
        
        # Check for specific timing requirements
        if '7 am' in query_lower or 'early breakfast' in query_lower:
            special_requirements.append("‚è∞ **Early Opening (7 AM):** Hotel restaurants, airport cafes, 24-hour diners")
            filter_notes.append("üåÖ Early breakfast (7 AM opening)")
        
        # Check for family requirements
        if 'family' in query_lower or 'kids' in query_lower or 'children' in query_lower:
            special_requirements.append("üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Family Features:** High chairs, kids menu, spacious seating")
            filter_notes.append("üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family-friendly with kids amenities")
        
        # Check for outdoor seating
        if 'outdoor' in query_lower or 'terrace' in query_lower:
            special_requirements.append("üå≥ **Outdoor Options:** Terrace seating, garden areas, street-side tables")
            filter_notes.append("üå≥ Outdoor seating available")
        
        # Check for large groups
        if 'large group' in query_lower or 'big group' in query_lower:
            special_requirements.append("üë• **Group Dining:** Reservations recommended, private dining rooms available")
            filter_notes.append("üë• Suitable for large groups")
        
        # Check for delivery
        if 'deliver' in query_lower or 'takeout' in query_lower:
            special_requirements.append("üöö **Delivery Options:** Yemeksepeti, Getir, Trendyol Yemek apps")
            filter_notes.append("üöö Delivery service available")
        
        # Check for romantic settings
        if 'romantic' in query_lower:
            special_requirements.append("üíï **Romantic Features:** Intimate lighting, Bosphorus views, quiet atmosphere")
            filter_notes.append("üíï Romantic atmosphere")
        
        # Check for live music
        if 'live music' in query_lower or 'entertainment' in query_lower:
            special_requirements.append("üéµ **Entertainment:** Live Turkish music, traditional performances")
            filter_notes.append("üéµ Live music and entertainment")
        
        if cuisines:
            filter_notes.append(f"ü•ò Specializing in {', '.join(cuisines)} cuisine")
        if dietary:
            filter_notes.append(f"üå± With {', '.join(dietary)} options")
        if budget:
            budget_level = budget[0]
            if budget_level == 'budget':
                filter_notes.append("üí∞ Budget-friendly options ($ - $$)")
            elif budget_level == 'luxury':
                filter_notes.append("‚ú® Premium dining experiences ($$$$ - $$$$$)")
        if time_refs:
            if 'morning' in time_refs and '7 am' not in query_lower:
                filter_notes.append("üåÖ Great for breakfast")
            elif 'evening' in time_refs:
                filter_notes.append("üåô Perfect for dinner")
        
        if filter_notes:
            response += "**Your preferences:**\n" + "\n".join(f"‚Ä¢ {note}" for note in filter_notes) + "\n\n"
        
        if special_requirements:
            response += "**Special Requirements:**\n" + "\n".join(f"‚Ä¢ {req}" for req in special_requirements) + "\n\n"
        
        # Add helpful tips
        response += "üí° **Helpful Tips:**\n"
        response += "‚Ä¢ Make reservations for upscale restaurants\n"
        response += "‚Ä¢ Try 'meze' (appetizers) for authentic experience\n"
        response += "‚Ä¢ Most restaurants open around 12:00 for lunch\n"
        response += "‚Ä¢ Dinner typically starts after 19:00\n\n"
        
        response += "üó∫Ô∏è Would you like directions to any of these restaurants or more specific recommendations?"
        
        return response

    def _handle_events_query(self, user_input: str, entities: Dict, user_profile: UserProfile) -> str:
        """Handle events-related queries with comprehensive fallback"""
        districts = entities.get('districts', [])
        time_refs = entities.get('time', [])
        
        # Try to use real events scheduler if available
        if self.events_available:
            try:
                events = self.events_scheduler.get_current_events()
                if events:
                    response = "üé≠ **Current Events in Istanbul**\n\n"
                    for i, event in enumerate(events[:6], 1):
                        response += f"**{i}. {event.get('title', 'Event')}**\n"
                        if event.get('date'):
                            response += f"üìÖ {event['date']}\n"
                        if event.get('venue'):
                            response += f"üìç {event['venue']}\n"
                        if event.get('category'):
                            response += f"üé® Category: {event['category']}\n"
                        response += "\n"
                    
                    response += "üí° **Tips:**\n"
                    response += "‚Ä¢ Check venue websites for ticket availability\n"
                    response += "‚Ä¢ Many venues are accessible by metro and bus\n"
                    response += "‚Ä¢ Consider booking in advance for popular events\n\n"
                    response += "üó∫Ô∏è Would you like directions to any venue or more event details?"
                    return response
            except Exception as e:
                logger.warning(f"Events integration error: {e}")
        
        # Enhanced fallback events response
        response = "üé≠ **Cultural Events & Activities in Istanbul**\n\n"
        
        # Time-specific recommendations
        if 'now' in time_refs or 'today' in time_refs:
            response += "**Today's Highlights:**\n\n"
        elif 'weekend' in time_refs:
            response += "**Weekend Events:**\n\n"
        elif 'evening' in time_refs:
            response += "**Evening Events:**\n\n"
        else:
            response += "**Current & Upcoming Events:**\n\n"
        
        # Location-specific events
        if districts:
            district = districts[0].lower()
            if district == 'sultanahmet':
                events_list = [
                    ("Hagia Sophia Evening Tours", "Guided tours with special lighting", "Hagia Sophia Museum", "Historical"),
                    ("Ottoman Palace Concerts", "Classical music in historic setting", "Topkapi Palace", "Music"),
                    ("Blue Mosque Cultural Talks", "Islamic art and architecture", "Blue Mosque Complex", "Cultural")
                ]
            elif district == 'beyoglu':
                events_list = [
                    ("Contemporary Art Exhibitions", "Modern Turkish and international art", "Istanbul Modern", "Art"),
                    ("Galata Tower Night Shows", "Panoramic city views with entertainment", "Galata Tower", "Entertainment"),
                    ("ƒ∞stiklal Street Performances", "Street artists and musicians", "ƒ∞stiklal Avenue", "Street Art")
                ]
            else:
                events_list = [
                    ("Neighborhood Cultural Center", "Local performances and exhibitions", f"{district.title()} Cultural Center", "Mixed"),
                    ("Community Arts Festival", "Local artists and craftspeople", f"{district.title()} Square", "Festival"),
                    ("Traditional Music Evening", "Folk and classical Turkish music", f"{district.title()} Concert Hall", "Music")
                ]
        else:
            events_list = [
                ("ƒ∞KSV Cultural Events", "International Istanbul festivals", "Various venues citywide", "International"),
                ("Istanbul Biennial", "Contemporary art from around the world", "Multiple locations", "Art"),
                ("Turkish State Opera", "Classical and modern opera performances", "Atat√ºrk Cultural Center", "Opera"),
                ("Bosphorus Concert Series", "Outdoor concerts with water views", "Bosphorus venues", "Music"),
                ("Historic Peninsula Tours", "Archaeological and cultural walks", "Old City", "Cultural"),
                ("Whirling Dervish Ceremonies", "Traditional Sufi spiritual performances", "Cultural centers", "Spiritual")
            ]
        
        # Display events
        for i, (title, desc, venue, category) in enumerate(events_list, 1):
            response += f"**{i}. {title}**\n"
            response += f"   {desc}\n"
            response += f"   üìç Venue: {venue}\n"
            response += f"   üé® Category: {category}\n\n"
        
        # Add helpful information
        response += "üé´ **Event Information:**\n"
        response += "‚Ä¢ Most cultural events: 19:00-21:00\n"
        response += "‚Ä¢ Museum exhibitions: 09:00-17:00 (closed Mondays)\n"
        response += "‚Ä¢ Concert venues: Check specific showtimes\n"
        response += "‚Ä¢ Many events offer English translations\n\n"
        
        response += "üí° **Getting There:**\n"
        response += "‚Ä¢ Metro: Most venues accessible via M2 line\n"
        response += "‚Ä¢ Tram: Convenient for Old City events\n"
        response += "‚Ä¢ Ferry: Scenic route to Bosphorus venues\n\n"
        
        response += "üéüÔ∏è Would you like ticket information or directions to any venue?"
        
        return response

    def _handle_transportation_query(self, user_input: str, entities: Dict, user_profile: UserProfile) -> str:
        """Handle transportation-related queries with advanced AI and real-time data"""
        try:
            # Use advanced transportation system if available
            if ADVANCED_TRANSPORT_AVAILABLE and self.transport_processor:
                logger.info("üöá Using advanced transportation system with IBB API")
                
                # Process query through enhanced system
                enhanced_response = self.transport_processor.process_transportation_query_sync(
                    user_input, entities, user_profile
                )
                
                if enhanced_response and enhanced_response.strip():
                    return enhanced_response
                    
            # Fallback to improved static response
            logger.info("üöá Using fallback transportation system")
            return self._get_fallback_transportation_response(user_input, entities, user_profile)
            
        except Exception as e:
            logger.error(f"Transportation query error: {e}")
            return self._get_fallback_transportation_response(user_input, entities, user_profile)
    
    def _get_fallback_transportation_response(self, user_input: str, entities: Dict, user_profile: UserProfile) -> str:
        """Fallback transportation response with correct information"""
        districts = entities.get('districts', [])
        transport_modes = entities.get('transport', [])
        
        response = "üöá **Transportation in Istanbul**\n\n"
        
        if districts:
            response += f"Getting to/from {', '.join(districts)}:\n\n"
        
        # Real-time status indicator
        current_time = datetime.now().strftime("%H:%M")
        response += f"üìç **Live Status** (Updated: {current_time})\n\n"
        
        response += "**Metro Lines:**\n"
        response += "‚Ä¢ M1A: Yenikapƒ± ‚Üî Halkalƒ± (serves Aksaray, Grand Bazaar)\n"
        response += "‚Ä¢ M2: Vezneciler ‚Üî Hacƒ±osman (serves Taksim, ≈ûi≈üli, Maslak)\n"
        response += "‚Ä¢ M3: Kirazlƒ± ‚Üî Ba≈üak≈üehir (business districts)\n"
        response += "‚Ä¢ M4: Kadƒ±k√∂y ‚Üî Tav≈üantepe (Asian side main line)\n"
        response += "‚Ä¢ M7: Kabata≈ü ‚Üî Mahmutbey (Golden Horn bridge line)\n"  
        response += "‚Ä¢ M11: Gayrettepe ‚Üî IST Airport (new airport express)\n\n"
        
        response += "**Popular Routes:**\n"
        response += "‚Ä¢ Airport to Taksim: M11 ‚Üí M2 (45 min)\n"
        response += "‚Ä¢ Sultanahmet to Asian side: T1 ‚Üí M2 ‚Üí M4 (30 min)\n"
        response += "‚Ä¢ Grand Bazaar to Galata: M1A ‚Üí M2 (20 min)\n\n"
        
        response += "**Other Transport:**\n"
        response += "‚Ä¢ üöå ƒ∞ETT Bus: City-wide network\n"
        response += "‚Ä¢ üöã Tram: T1 (Historic Peninsula), T4 (Topkapƒ±)\n" 
        response += "‚Ä¢ ‚õ¥Ô∏è Ferry: Bosphorus & Golden Horn routes\n"
        response += "‚Ä¢ üöï Taxi: BiTaksi, Uber available\n\n"
        
        response += "üí≥ **Payment:** ƒ∞stanbulkart for all public transport\n"
        response += "üí° Need specific directions? Ask: 'How to get from X to Y?'"
        
        return response

    def _handle_attractions_query(self, user_input: str, entities: Dict, user_profile: UserProfile) -> str:
        """Handle attractions-related queries"""
        districts = entities.get('districts', [])
        
        response = "üèõÔ∏è **Istanbul Attractions**\n\n"
        
        if districts:
            response += f"Top attractions in {', '.join(districts)}:\n\n"
        else:
            response += "Must-visit attractions:\n\n"
        
        attractions = [
            ("Hagia Sophia", "Sultanahmet", "Historic Byzantine cathedral and Ottoman mosque"),
            ("Blue Mosque", "Sultanahmet", "Stunning Ottoman architecture with six minarets"),
            ("Topkapi Palace", "Sultanahmet", "Former Ottoman palace with treasury and views"),
            ("Galata Tower", "Galata", "Medieval tower with panoramic city views"),
            ("Grand Bazaar", "Beyazƒ±t", "Historic covered market with 4,000 shops")
        ]
        
        for i, (name, district, desc) in enumerate(attractions, 1):
            response += f"**{i}. {name}** ({district})\n   {desc}\n\n"
        
        response += "üìç Would you like directions or opening hours for any of these?"
        
        return response

    def _handle_general_query(self, user_input: str, entities: Dict, user_profile: UserProfile) -> str:
        """Handle general queries"""
        return f"""Hello! üåü Welcome to Istanbul!

I can help you with:
‚Ä¢ üçΩÔ∏è Restaurant recommendations
‚Ä¢ üé≠ Current events and cultural activities  
‚Ä¢ üöá Transportation and directions
‚Ä¢ üèõÔ∏è Attractions and sightseeing
‚Ä¢ üèòÔ∏è Neighborhood guides and district information
‚Ä¢ üí° Local tips and hidden gems

**Examples**:
‚Ä¢ "Restaurants in Kadƒ±k√∂y"
‚Ä¢ "What's the vibe in Be≈üikta≈ü?"
‚Ä¢ "Complete guide to Sultanahmet"
‚Ä¢ "Compare ≈ûi≈üli and √úsk√ºdar"

What would you like to explore in Istanbul today?"""

    def _handle_neighborhood_guide_query(self, user_input: str, entities: Dict, user_profile: UserProfile, context: Optional['ConversationContext'] = None) -> str:
        """Handle neighborhood/district-specific queries with comprehensive guidance"""
        
        if not self.neighborhood_guide:
            return f"""üèòÔ∏è **Neighborhood Guide Service**

I'd love to help with neighborhood information, but the neighborhood guide service is currently not available.

**I can still help you with:**
‚Ä¢ üçΩÔ∏è Restaurant recommendations by district
‚Ä¢ üé≠ Events and cultural activities
‚Ä¢ üöá Transportation information
‚Ä¢ üèõÔ∏è Attractions and sightseeing

Try asking: "Restaurants in [district name]" or "How to get to [location]" """
        
        user_input_lower = user_input.lower()
        
        # Find districts mentioned in the query
        matched_districts = self.neighborhood_guide.find_districts_by_keywords(user_input)
        
        # Enhanced district detection - try alternative spellings and patterns
        if not matched_districts:
            # Manual district detection for common variations
            district_patterns = {
                'kadƒ±k√∂y': ['kadikoy', 'kadƒ±k√∂y', 'kadik√∂y'],
                'be≈üikta≈ü': ['besiktas', 'be≈üikta≈ü', 'besikta≈ü'],
                'sultanahmet': ['sultanahmet'],
                '≈üi≈üli': ['sisli', '≈üi≈üli', 'sisli'],
                '√ºsk√ºdar': ['uskudar', '√ºsk√ºdar', 'uskudar'],
                'fatih': ['fatih'],
                'sarƒ±yer': ['sariyer', 'sarƒ±yer', 'sariyer']
            }
            
            for standard_name, variations in district_patterns.items():
                if any(variation in user_input_lower for variation in variations):
                    matched_districts = [standard_name]
                    break
        
        # Check for specific query types
        if any(word in user_input_lower for word in ['compare', 'difference', 'versus', 'vs', 'which is better']):
            return self._handle_district_comparison_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['character', 'vibe', 'atmosphere', 'feel', 'what is like']):
            return self._handle_district_character_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['how to get', 'transport', 'travel to', 'go to']):
            return self._handle_district_transport_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['restaurants', 'eat', 'food', 'dining']):
            return self._handle_district_dining_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['nightlife', 'bars', 'clubs', 'night']):
            return self._handle_district_nightlife_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['attractions', 'sights', 'visit', 'see']):
            return self._handle_district_attractions_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['shopping', 'shop', 'buy', 'mall']):
            return self._handle_district_shopping_query(user_input, matched_districts, user_profile)
        
        elif any(word in user_input_lower for word in ['guide', 'comprehensive', 'everything', 'complete']):
            return self._handle_comprehensive_district_guide(user_input, matched_districts, user_profile, context)
        
        else:
            # General district information
            return self._handle_general_district_info(user_input, matched_districts, user_profile)
    
    def _handle_district_comparison_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle district comparison queries"""
        if len(districts) < 2:
            return """üèòÔ∏è **District Comparison**

To compare neighborhoods, please mention at least two districts. For example:
‚Ä¢ "Compare Be≈üikta≈ü and Kadƒ±k√∂y"
‚Ä¢ "What's the difference between Sultanahmet and Fatih?"
‚Ä¢ "Which is better for nightlife: Be≈üikta≈ü vs ≈ûi≈üli?"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        comparison = self.neighborhood_guide.get_district_comparison(districts)
        
        response = "üèòÔ∏è **District Comparison**\n\n"
        
        for district_name, info in comparison["districts"].items():
            response += f"**{district_name}**\n"
            response += f"‚Ä¢ **Type**: {info['type'].replace('_', ' ').title()}\n"
            response += f"‚Ä¢ **Vibe**: {info['vibe']}\n"
            response += f"‚Ä¢ **Best Time**: {', '.join(info['best_time'])}\n"
            response += f"‚Ä¢ **Budget**: {info['budget_estimate']}\n"
            response += f"‚Ä¢ **Categories**: {', '.join(info['categories'])}\n\n"
        
        if comparison["summary"]:
            response += "**Quick Summary:**\n"
            for category, district_list in comparison["summary"].items():
                if district_list:
                    response += f"‚Ä¢ **{category.replace('_', ' ').title()}**: {', '.join(district_list)}\n"
        
        return response
    
    def _handle_district_character_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle queries about district character and atmosphere"""
        if not districts:
            return """üèòÔ∏è **Neighborhood Character Guide**

Please specify a district to learn about its character. For example:
‚Ä¢ "What's the vibe in Kadƒ±k√∂y?"
‚Ä¢ "Tell me about Be≈üikta≈ü atmosphere"
‚Ä¢ "What is Sultanahmet like?"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üèòÔ∏è **Neighborhood Character**\n\n"
        
        for district_key in districts:
            character = self.neighborhood_guide.get_neighborhood_character(district_key)
            if character:
                district = self.neighborhood_guide.get_district_guide(district_key)
                response += f"**{district.name}**\n"
                response += f"üé≠ **Vibe**: {character.vibe}\n"
                response += f"üë• **Crowd**: {character.crowd}\n"
                response += f"üåü **Atmosphere**: {character.atmosphere}\n"
                response += f"‚è∞ **Best Time**: {', '.join([t.value for t in character.best_time])}\n"
                
                if character.local_saying:
                    response += f"üí¨ **Local Saying**: {character.local_saying}\n"
                
                if character.insider_tip:
                    response += f"üí° **Insider Tip**: {character.insider_tip}\n"
                
                response += "\n"
        
        return response
    
    def _handle_district_transport_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle transportation queries for districts"""
        if not districts:
            return """üöá **District Transportation Guide**

Please specify a district for transportation information. For example:
‚Ä¢ "How to get to Be≈üikta≈ü?"
‚Ä¢ "Transportation to Kadƒ±k√∂y"
‚Ä¢ "Best way to reach Sultanahmet"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üöá **Transportation Guide**\n\n"
        
        for district_key in districts:
            district = self.neighborhood_guide.get_district_guide(district_key)
            if district:
                response += f"**Getting to {district.name}:**\n"
                for transport_type, details in district.getting_there.items():
                    response += f"‚Ä¢ **{transport_type.title()}**: {details}\n"
                response += "\n"
        
        return response
    
    def _handle_district_dining_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle dining queries for specific districts"""
        if not districts:
            return """üçΩÔ∏è **District Dining Guide**

Please specify a district for restaurant recommendations. For example:
‚Ä¢ "Restaurants in Kadƒ±k√∂y"
‚Ä¢ "Where to eat in Be≈üikta≈ü?"
‚Ä¢ "Best food in Sultanahmet"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üçΩÔ∏è **District Dining Guide**\n\n"
        
        for district_key in districts:
            restaurants = self.neighborhood_guide.get_recommendations_by_category(district_key, "restaurants")
            if restaurants:
                district = self.neighborhood_guide.get_district_guide(district_key)
                response += f"**{district.name} Restaurants:**\n\n"
                
                for rest in restaurants:
                    response += f"**{rest.name}** ({rest.type})\n"
                    response += f"üìç {rest.address}\n"
                    response += f"üìù {rest.description}\n"
                    
                    if rest.opening_hours:
                        response += f"üïê {rest.opening_hours}\n"
                    
                    if rest.insider_tip:
                        response += f"üí° **Tip**: {rest.insider_tip}\n"
                    
                    response += f"üèÜ Local Favorite: {'Yes' if rest.local_favorite else 'No'}\n"
                    response += f"üåç Tourist Friendly: {'Yes' if rest.tourist_friendly else 'No'}\n\n"
        
        return response
    
    def _handle_district_nightlife_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle nightlife queries for specific districts"""
        if not districts:
            return """üåô **District Nightlife Guide**

Please specify a district for nightlife recommendations. For example:
‚Ä¢ "Nightlife in Be≈üikta≈ü"
‚Ä¢ "Bars in Kadƒ±k√∂y"
‚Ä¢ "Clubs in ≈ûi≈üli"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üåô **District Nightlife Guide**\n\n"
        
        for district_key in districts:
            nightlife = self.neighborhood_guide.get_recommendations_by_category(district_key, "nightlife")
            if nightlife:
                district = self.neighborhood_guide.get_district_guide(district_key)
                response += f"**{district.name} Nightlife:**\n\n"
                
                for venue in nightlife:
                    response += f"**{venue.name}** ({venue.type})\n"
                    response += f"üìç {venue.address}\n"
                    response += f"üìù {venue.description}\n"
                    
                    if venue.opening_hours:
                        response += f"üïê {venue.opening_hours}\n"
                    
                    if venue.insider_tip:
                        response += f"üí° **Tip**: {venue.insider_tip}\n"
                    
                    response += f"üèÜ Local Favorite: {'Yes' if venue.local_favorite else 'No'}\n\n"
            else:
                district = self.neighborhood_guide.get_district_guide(district_key)
                if district:
                    response += f"**{district.name}**: Limited nightlife options, more family-oriented district.\n\n"
        
        return response
    
    def _handle_district_attractions_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle attraction queries for specific districts"""
        if not districts:
            return """üèõÔ∏è **District Attractions Guide**

Please specify a district for attraction recommendations. For example:
‚Ä¢ "Attractions in Sultanahmet"
‚Ä¢ "What to see in Fatih?"
‚Ä¢ "Sights in √úsk√ºdar"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üèõÔ∏è **District Attractions Guide**\n\n"
        
        for district_key in districts:
            attractions = self.neighborhood_guide.get_recommendations_by_category(district_key, "attractions")
            if attractions:
                district = self.neighborhood_guide.get_district_guide(district_key)
                response += f"**{district.name} Attractions:**\n\n"
                
                for attr in attractions:
                    response += f"**{attr.name}** ({attr.type})\n"
                    response += f"üìç {attr.address}\n"
                    response += f"üìù {attr.description}\n"
                    
                    if attr.opening_hours:
                        response += f"üïê {attr.opening_hours}\n"
                    
                    if attr.insider_tip:
                        response += f"üí° **Tip**: {attr.insider_tip}\n"
                    
                    response += f"üèÜ Local Favorite: {'Yes' if attr.local_favorite else 'No'}\n\n"
        
        return response
    
    def _handle_district_shopping_query(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle shopping queries for specific districts"""
        if not districts:
            return """üõçÔ∏è **District Shopping Guide**

Please specify a district for shopping recommendations. For example:
‚Ä¢ "Shopping in ≈ûi≈üli"
‚Ä¢ "Where to shop in Fatih?"
‚Ä¢ "Malls in Be≈üikta≈ü"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        response = "üõçÔ∏è **District Shopping Guide**\n\n"
        
        for district_key in districts:
            shopping = self.neighborhood_guide.get_recommendations_by_category(district_key, "shopping")
            if shopping:
                district = self.neighborhood_guide.get_district_guide(district_key)
                response += f"**{district.name} Shopping:**\n\n"
                
                for shop in shopping:
                    response += f"**{shop.name}** ({shop.type})\n"
                    response += f"üìç {shop.address}\n"
                    response += f"üìù {shop.description}\n"
                    
                    if shop.opening_hours:
                        response += f"üïê {shop.opening_hours}\n"
                    
                    if shop.insider_tip:
                        response += f"üí° **Tip**: {shop.insider_tip}\n"
                    
                    response += f"üèÜ Local Favorite: {'Yes' if shop.local_favorite else 'No'}\n\n"
            else:
                district = self.neighborhood_guide.get_district_guide(district_key)
                if district:
                    response += f"**{district.name}**: Limited shopping options, more focused on other activities.\n\n"
        
        return response
    
    def _handle_comprehensive_district_guide(self, user_input: str, districts: List[str], user_profile: UserProfile, context: Optional['ConversationContext'] = None) -> str:
        """Handle comprehensive district guide requests"""
        if not districts:
            return """üìñ **Comprehensive District Guide**

Please specify a district for a complete guide. For example:
‚Ä¢ "Complete guide to Kadƒ±k√∂y"
‚Ä¢ "Everything about Be≈üikta≈ü"
‚Ä¢ "Comprehensive Sultanahmet guide"

Available districts: Be≈üikta≈ü, ≈ûi≈üli, √úsk√ºdar, Kadƒ±k√∂y, Fatih, Sultanahmet, Sarƒ±yer"""
        
        # Use first district for comprehensive guide
        district_key = districts[0]
        
        # Get user interests from profile if available
        user_interests = None
        if hasattr(user_profile, 'preferences') and user_profile.preferences:
            user_interests = user_profile.preferences.get('interests', [])
        
        guide = self.neighborhood_guide.generate_comprehensive_guide(district_key, user_interests)
        
        if "error" in guide:
            return f"‚ùå {guide['error']}"
        
        response = f"üìñ **Comprehensive Guide to {guide['district_name']}**\n\n"
        
        # Character
        character = guide['character']
        response += "üé≠ **Character & Atmosphere**\n"
        response += f"‚Ä¢ **Vibe**: {character['vibe']}\n"
        response += f"‚Ä¢ **Crowd**: {character['crowd']}\n"
        response += f"‚Ä¢ **Atmosphere**: {character['atmosphere']}\n"
        response += f"‚Ä¢ **Best Time**: {', '.join(character['best_time'])}\n"
        
        if character['local_saying']:
            response += f"‚Ä¢ **Local Saying**: {character['local_saying']}\n"
        
        if character['insider_tip']:
            response += f"‚Ä¢ **Insider Tip**: {character['insider_tip']}\n"
        
        response += "\n"
        
        # Transportation
        response += "üöá **Getting There**\n"
        for transport_type, details in guide['getting_there'].items():
            response += f"‚Ä¢ **{transport_type.title()}**: {details}\n"
        response += "\n"
        
        # Recommendations (top picks)
        if guide['recommendations']:
            response += "üåü **Top Recommendations**\n"
            for category, recs in guide['recommendations'].items():
                if recs:  # Only show categories with recommendations
                    response += f"\n**{category.title()}:**\n"
                    for rec in recs[:2]:  # Show top 2 per category
                        response += f"‚Ä¢ **{rec['name']}**: {rec['description']}\n"
        
        # Practical information
        response += f"\nüí∞ **Budget Estimate**: {guide['budget_estimate']}\n"
        response += f"üõ°Ô∏è **Safety**: {guide['safety_notes']}\n\n"
        
        # Quick tips
        if guide['practical_tips']:
            response += "üí° **Quick Tips**:\n"
            for tip in guide['practical_tips'][:3]:
                response += f"‚Ä¢ {tip}\n"
        
        response += "\nüó∫Ô∏è *For walking routes, local customs, and detailed recommendations, ask for specific categories!*"
        
        return response
    
    def _handle_general_district_info(self, user_input: str, districts: List[str], user_profile: UserProfile) -> str:
        """Handle general district information requests"""
        if not districts:
            available_districts = ", ".join(self.neighborhood_guide.get_all_districts())
            return f"""üèòÔ∏è **Istanbul Neighborhood Guide**

I can provide detailed information about Istanbul's neighborhoods!

**Available Districts**: {available_districts}

**Ask me about**:
‚Ä¢ Character and atmosphere
‚Ä¢ Transportation options  
‚Ä¢ Restaurants and dining
‚Ä¢ Nightlife and bars
‚Ä¢ Attractions and sights
‚Ä¢ Shopping areas
‚Ä¢ Comprehensive guides
‚Ä¢ District comparisons

**Examples**:
‚Ä¢ "What's the vibe in Kadƒ±k√∂y?"
‚Ä¢ "Restaurants in Be≈üikta≈ü"
‚Ä¢ "Complete guide to Sultanahmet"
‚Ä¢ "Compare ≈ûi≈üli and √úsk√ºdar"

What would you like to know about Istanbul's neighborhoods?"""
        
        response = "üèòÔ∏è **District Information**\n\n"
        
        for district_key in districts:
            district = self.neighborhood_guide.get_district_guide(district_key)
            if district:
                response += f"**{district.name}** ({district.district_type.value.replace('_', ' ').title()})\n"
                response += f"üé≠ {district.character.vibe}\n"
                response += f"üí∞ Budget: {district.budget_estimate}\n"
                response += f"üìç Categories: {', '.join(district.recommendations.keys())}\n\n"
        
        response += "üí° *Ask for specific information like 'restaurants in [district]' or 'nightlife in [district]' for detailed recommendations!*"
        
        return response

    def _enhance_multi_intent_response(self, user_input: str, intents: List[str], entities: Dict, user_profile: UserProfile) -> str:
        """Handle multi-intent queries with enhanced responses"""
        if not intents:
            return self._generate_fallback_response(user_input)
        
        primary_intent = intents[0]
        response = self._process_by_intent(user_input, primary_intent, entities, user_profile)
        
        # Add suggestions for other detected intents
        if len(intents) > 1:
            suggestions = []
            for intent in intents[1:]:
                if intent == "restaurant":
                    suggestions.append("üçΩÔ∏è Would you also like restaurant recommendations?")
                elif intent == "events":
                    suggestions.append("üé≠ Interested in current events and shows?")
                elif intent == "transportation":
                    suggestions.append("üöá Need help with transportation?")
                elif intent == "attractions":
                    suggestions.append("üèõÔ∏è Want to explore more attractions?")
            
            if suggestions:
                response += "\n\n**You might also be interested in:**\n" + "\n".join(suggestions)
        
        return response

    def _get_or_request_gps_location(self, user_profile: UserProfile) -> Optional[Dict[str, float]]:
        """Get user's GPS location or request it"""
        if user_profile.gps_location:
            return user_profile.gps_location
        
        # For now, return None - in a real app, this would trigger location permission request
        return None

    def classify_intent(self, user_input: str) -> str:
        """Public interface for intent classification - used by external systems"""
        return self._enhance_intent_classification(user_input)
    
    def _enhance_intent_classification(self, user_input: str) -> str:
        """Enhanced intent classification with better complex query handling"""
        intent_signals = self.entity_recognizer.detect_intent_signals(user_input)
        primary_intent = self._determine_primary_intent(intent_signals)
        
        user_lower = user_input.lower()
        
        # Priority 1: Enhanced restaurant detection - include Turkish dining culture terms
        restaurant_keywords = [
            'restaurant', 'eat', 'food', 'meal', 'hungry', 'dine', 'dining', 'cuisine', 'breakfast', 'lunch', 'dinner',
            'pide', 'kebab', 'meze', 'coffee', 'dessert', 'baklava', 'turkish coffee', 'street food',
            'seafood', 'vegetarian', 'vegan', 'halal', 'kosher', 'gluten-free', 'lactose-free', 'diabetic',
            'ottoman cuisine', 'anatolian', 'meyhane', 'd√∂ner', 'k√∂fte', 'fish', 'bosphorus',
            'rooftop', 'romantic dinner', 'family-friendly', 'kids menu', 'delivery', 'takeout',
            'outdoor seating', 'live music', 'fine dining', 'budget', 'cheap', 'expensive', 'luxury',
            'business lunch', 'celebration', 'anniversary', 'waterfront', 'wi-fi', 'digital nomad',
            'parking', 'pet-friendly', 'wheelchair accessible', 'private dining', 'corporate',
            'unlimited √ßay', 'iftar', 'ramadan', '√ßay', 'tea', 'wine pairing', 'alcohol',
            'cooking class', 'chef table', 'celebrity', 'palace', '24-hour', 'late night',
            'golden horn', 'fusion', 'organic', 'healthy', 'pregnant', 'sugar-free'
        ]
        
        # Check for restaurant keywords
        if any(word in user_lower for word in restaurant_keywords):
            return 'restaurant_query'
        
        # Priority 2: Events detection - but exclude dining-related cultural activities
        events_keywords = ['event', 'show', 'performance', 'exhibition', 'concert', 'happening', 'cultural']
        if any(word in user_lower for word in events_keywords):
            # Check if it's actually about dining culture (e.g., "meyhane with traditional music")
            dining_context = any(word in user_lower for word in ['restaurant', 'eat', 'food', 'dining', 'meyhane'])
            if dining_context:
                return 'restaurant_query'
            else:
                return 'events_query'
        
        # Priority 3: Attraction detection
        elif any(word in user_lower for word in ['visit', 'see', 'attraction', 'museum', 'palace', 'mosque', 'tower']):
            return 'attraction_query'
        
        # Priority 4: Transportation detection  
        elif any(word in user_lower for word in ['transport', 'metro', 'bus', 'taxi', 'how to get', 'directions']):
            return 'transportation_query'
        
        return primary_intent

    def _is_restaurant_query(self, user_input: str) -> bool:
        """Check if query is restaurant-related for backward compatibility"""
        restaurant_keywords = ['restaurant', 'eat', 'food', 'meal', 'hungry', 'dine', 'cuisine', 'breakfast', 'lunch', 'dinner']
        return any(keyword in user_input.lower() for keyword in restaurant_keywords)

    def _handle_coffee_dessert_query(self, user_input: str, entities: Dict) -> str:
        """Handle Turkish coffee and dessert queries"""
        return """üçΩÔ∏è **Best Turkish Coffee & Desserts in Istanbul**

‚òï **Top Turkish Coffee Spots:**

**1. Kurukahveci Mehmet Efendi** $
   Historic coffee roastery since 1871
   üìç Location: Emin√∂n√º, near Spice Bazaar
   ‚òï Specialty: Traditional Turkish coffee

**2. Fazƒ±l Bey'in T√ºrk Kahvesi** $
   Authentic neighborhood coffee house
   üìç Location: Kadƒ±k√∂y
   ‚òï Specialty: Hand-ground Turkish coffee

**3. Mandabatmaz** $
   Famous tiny coffee shop in Beyoƒülu
   üìç Location: Olivia Passage, Beyoƒülu
   ‚òï Specialty: Strong Turkish coffee

üßÅ **Best Dessert Places:**

**4. Ko√ßak Baklava** $$
   Premium baklava since 1956
   üçØ Specialty: Pistachio baklava, k√ºnefe

**5. G√ºll√ºoƒülu Baklava** $$
   Famous Gaziantep baklava house
   üçØ Specialty: Traditional baklava varieties

**6. Caf√© Privato** $$
   Modern dessert cafe with Ottoman sweets
   üçÆ Specialty: Muhallebi, rice pudding

üí° **Tips:**
‚Ä¢ Turkish coffee is served with Turkish delight
‚Ä¢ Best enjoyed slowly with good company
‚Ä¢ Try baklava with pistachio from Gaziantep
‚Ä¢ Many places open early for breakfast coffee

‚òï Perfect spots for authentic Turkish coffee culture!"""

    def _handle_pide_query(self, user_input: str, entities: Dict) -> str:
        """Handle Turkish pide queries"""
        return """üçΩÔ∏è **Best Turkish Pide Places in Istanbul**

ü•ñ **Authentic Pide Restaurants:**

**1. Develi Pide** $$
   Famous for Gaziantep-style pide
   üìç Location: Samatya & multiple locations
   ü•© Specialty: Lamb pide, cheese pide

**2. Borsam Ta≈üfƒ±rƒ±n** $
   Traditional stone oven pide house
   üìç Location: Karak√∂y
   üî• Specialty: Stone-baked pide varieties

**3. Hamdi Pide** $$
   Legendary pide restaurant
   üìç Location: Emin√∂n√º, near Golden Horn
   üßÄ Specialty: Cheese pide, mixed pide

**4. Cennet Pide** $
   Local favorite for cheap good pide
   üìç Location: Various neighborhoods
   üí∞ Specialty: Budget-friendly pide options

**5. √áamlƒ±ca Pide** $$
   Family-run pide house
   üìç Location: Asian side locations
   ü•© Specialty: Meat pide, Turkish sausage pide

üí° **Pide Tips:**
‚Ä¢ Best eaten fresh from stone ovens
‚Ä¢ Try 'karƒ±≈üƒ±k' (mixed) pide for variety
‚Ä¢ Pide shops usually open from lunch till late
‚Ä¢ Served with fresh salad and ayran (yogurt drink)

ü•ñ Enjoy authentic Turkish pide experience!"""

    def _handle_street_food_query(self, user_input: str, entities: Dict) -> str:
        """Handle street food queries"""
        return """üçΩÔ∏è **Best Street Food Spots in Istanbul**

üåØ **Top Street Food Areas:**

**1. Emin√∂n√º - Fish Sandwich Boats**
   Famous floating fish sandwich vendors
   üìç Location: Galata Bridge area
   üêü Specialty: Fresh grilled fish sandwiches

**2. Taksim √ái√ßek Pasajƒ±**
   Historic flower passage with meyhanes
   üìç Location: ƒ∞stiklal Street
   üç∫ Specialty: Meze, rakƒ±, street musicians

**3. Kadƒ±k√∂y Market Area**
   Local street food paradise
   üìç Location: Kadƒ±k√∂y ferry area
   ü•ô Specialty: D√∂ner, kokore√ß, midye dolma

**4. Galata Bridge Lower Level**
   Restaurant strip under the bridge
   üìç Location: Golden Horn
   ü¶ê Specialty: Fresh seafood, balƒ±k ekmek

**5. Ortak√∂y Square**
   Weekend street food hub
   üìç Location: Bosphorus waterfront
   ü•î Specialty: Kumpir (stuffed baked potato)

**Popular Street Foods:**
‚Ä¢ üåØ D√∂ner kebab - Rotating meat wraps
‚Ä¢ ü•™ Balƒ±k ekmek - Fish sandwiches
‚Ä¢ ü¶™ Midye dolma - Stuffed mussels
‚Ä¢ ü•î Kumpir - Loaded baked potatoes
‚Ä¢ üå≠ Kokore√ß - Grilled lamb intestines
‚Ä¢ üßÄ Tost - Turkish grilled cheese

üí° **Street Food Tips:**
‚Ä¢ Look for busy stalls with high turnover
‚Ä¢ Peak times: lunch and evening
‚Ä¢ Most vendors speak basic English
‚Ä¢ Cash only at most street stalls

üåØ Experience authentic Istanbul street culture!"""

    def _handle_gluten_free_query(self, user_input: str, entities: Dict) -> str:
        """Handle gluten-free restaurant queries"""
        districts = entities.get('districts', [])
        location_text = f" in {districts[0]}" if districts else ""
        
        return f"""üçΩÔ∏è **Gluten-Free Restaurants{location_text}**

üåæ **Gluten-Free Friendly Restaurants:**

**1. Cooklife**
   Dedicated gluten-free bakery & cafe
   üìç Location: Bebek, Bomonti
   ‚úÖ Specialty: GF bread, pastries, meals

**2. Zencefil Restaurant**
   Vegetarian with many GF options
   üìç Location: Galata
   ü•ó Specialty: Organic, gluten-free dishes

**3. Seasons Restaurant (Four Seasons)**
   Upscale dining with GF menu
   üìç Location: Sultanahmet
   ‚≠ê Specialty: International GF fine dining

**4. House Cafe**
   Popular chain with GF options
   üìç Location: Multiple locations
   üç∞ Specialty: GF desserts, salads

**5. Mikla Restaurant**
   Award-winning with GF accommodations
   üìç Location: Beyoƒülu
   üèÜ Specialty: Modern Turkish GF dishes

**Turkish GF Options:**
‚Ä¢ üçñ Grilled meats (without marinade)
‚Ä¢ ü•ó Fresh salads and vegetables
‚Ä¢ üßÄ Turkish cheese varieties
‚Ä¢ ü´í Olive oil dishes
‚Ä¢ üçØ Rice-based desserts (avoid wheat-based)

üí° **GF Tips in Istanbul:**
‚Ä¢ Learn key phrases: "Gluten yok" (no gluten)
‚Ä¢ Many traditional dishes naturally GF
‚Ä¢ Check rice vs bulgur in dishes
‚Ä¢ Ask about cross-contamination
‚Ä¢ Hotel concierges can help translate dietary needs

üåæ Safe and delicious gluten-free dining in Istanbul!"""

    def _handle_lactose_free_query(self, user_input: str, entities: Dict) -> str:
        """Handle lactose-free and dairy intolerance queries"""
        districts = entities.get('districts', [])
        location_text = f" in {districts[0]}" if districts else ""
        
        return f"""üçΩÔ∏è **Lactose-Free Restaurants{location_text}**

ü•õ **Dairy-Free Friendly Options:**

**1. Zencefil Restaurant**
   Vegetarian with extensive dairy-free menu
   üìç Location: Galata
   üå± Specialty: Organic, plant-based dishes

**2. Cooklife**
   Health-focused with fresh preparations
   üìç Location: Bebek, Bomonti
   ‚úÖ Specialty: Fresh juices, wholesome meals

**3. Pandora Bookstore Cafe**
   Cultural cafe with dairy alternatives
   üìç Location: Beyoƒülu
   üìö Specialty: Oat milk coffee, vegan pastries

**4. Neolokal**
   Modern Turkish with health-conscious preparations
   üìç Location: Galata
   üçΩÔ∏è Specialty: Lactose-free Turkish cuisine adaptations

**5. Seasons Restaurant (Four Seasons)**
   Upscale dining with special dietary menus
   üìç Location: Sultanahmet
   ‚≠ê Specialty: Custom lactose-free fine dining

**Turkish Lactose-Free Options:**
‚Ä¢ ü•© Grilled meats without dairy marinades
‚Ä¢ ü•ó Fresh vegetable dishes with olive oil
‚Ä¢ üçö Rice-based dishes (pilav varieties)
‚Ä¢ ü´í Traditional olive oil mezze
‚Ä¢ ü•ú Nuts and dried fruits

üí° **Lactose-Free Tips:**
‚Ä¢ Learn to say: "S√ºt √ºr√ºn√º yok" (no dairy products)
‚Ä¢ Turkish cuisine has many naturally dairy-free dishes
‚Ä¢ Ask about cooking oils (some use butter)
‚Ä¢ Traditional Turkish coffee is naturally dairy-free
‚Ä¢ Many restaurants can accommodate with advance notice

ü•õ Safe and delicious dairy-free dining in Istanbul!"""

    def _handle_meyhane_query(self, user_input: str, entities: Dict) -> str:
        """Handle Turkish meyhane (tavern) queries with traditional music"""
        return """üçΩÔ∏è **Authentic Turkish Meyhanes with Traditional Music**

üéµ **Traditional Meyhanes:**

**1. Nevizade Sokak Meyhanes**
   Historic meyhane street in Beyoƒülu
   üìç Location: Nevizade Street, Beyoƒülu
   üéº Specialty: Live fasƒ±l music, classic meze

**2. √ái√ßek Pasajƒ± (Flower Passage)**
   Historic covered passage with multiple meyhanes
   üìç Location: ƒ∞stiklal Street, Beyoƒülu
   üå∏ Specialty: Traditional atmosphere, street musicians

**3. Refik Restaurant**
   Century-old family meyhane
   üìç Location: T√ºnel, Beyoƒülu
   üèõÔ∏è Specialty: Historic setting, live Turkish music

**4. Sofyalƒ± 9**
   Modern take on traditional meyhane
   üìç Location: Asmalƒ±mescit, Beyoƒülu
   üé≠ Specialty: Contemporary atmosphere, quality meze

**5. Yakup 2**
   Authentic neighborhood meyhane
   üìç Location: Asmalƒ±mescit, Beyoƒülu
   üç∑ Specialty: Traditional rakƒ± culture, live music

**6. Pandeli**
   Historic Ottoman meyhane atmosphere
   üìç Location: Emin√∂n√º, Spice Bazaar
   üè∫ Specialty: Ottoman-era ambiance, traditional service

**Meyhane Experience:**
‚Ä¢ ü•É **Rakƒ±** - Traditional anise-flavored spirit
‚Ä¢ üßÑ **Meze** - Small appetizer dishes (20+ varieties)
‚Ä¢ üéµ **Fasƒ±l** - Traditional Turkish folk music
‚Ä¢ üïò **Late dining** - Usually starts after 8 PM
‚Ä¢ üë• **Social dining** - Best experienced with friends

üí° **Meyhane Tips:**
‚Ä¢ Order multiple meze to share
‚Ä¢ Rakƒ± is traditionally mixed with water
‚Ä¢ Music gets livelier as the night progresses
‚Ä¢ Reservations recommended for weekends
‚Ä¢ Learn some Turkish songs for sing-alongs!

üéµ Experience authentic Turkish tavern culture!"""

    def _handle_waterfront_fish_query(self, user_input: str, entities: Dict) -> str:
        """Handle waterfront dining with fresh fish queries"""
        return """üçΩÔ∏è **Waterfront Dining with Fresh Bosphorus Fish**

üêü **Best Waterfront Fish Restaurants:**

**1. Lacivert Restaurant**
   Upscale waterfront dining with Bosphorus views
   üìç Location: Anadolu Hisarƒ±, Asian side
   üåä Specialty: Fresh daily catch, panoramic water views

**2. Poseidon Restaurant**
   Historic fish restaurant by the water
   üìç Location: Bebek, Bosphorus shore
   ü¶ê Specialty: Grilled fish, waterfront terrace

**3. Balƒ±k√ßƒ± Sabahattin**
   Traditional fish house since 1927
   üìç Location: Sultanahmet (historic fish specialist)
   üêü Specialty: Classic Turkish fish preparations

**4. Sur Balƒ±k**
   Fresh seafood on the Asian side
   üìç Location: Kadƒ±k√∂y waterfront
   ü¶ë Specialty: Daily catch from local fishermen

**5. Galata Bridge Fish Restaurants**
   Multiple restaurants under the bridge
   üìç Location: Golden Horn waterfront
   üåâ Specialty: Casual dining with water views

**6. Feriye Palace Restaurant**
   Ottoman palace turned restaurant
   üìç Location: Ortak√∂y, Bosphorus shore
   üè∞ Specialty: Elegant waterfront dining, fresh fish

**Fresh Fish Experience:**
‚Ä¢ üêü **Daily catch** displayed on ice
‚Ä¢ üî• **Grilled whole fish** - Turkish specialty
‚Ä¢ ü•ó **Seasonal salads** and mezze starters
‚Ä¢ üç∑ **Turkish white wines** pair perfectly
‚Ä¢ üåÖ **Sunset dining** on terraces

üí° **Waterfront Fish Tips:**
‚Ä¢ Ask to see the daily catch selection
‚Ä¢ Grilled levrek (sea bass) and √ßipura (sea bream) are excellent
‚Ä¢ Order rakƒ± or white wine with fish
‚Ä¢ Best times: lunch or early dinner for views
‚Ä¢ Reservations essential for waterfront tables

üåä Fresh from the Bosphorus to your plate!"""

    def _handle_complex_dietary_query(self, user_input: str, entities: Dict) -> str:
        """Handle complex dietary restrictions and medical needs"""
        query_lower = user_input.lower()
        
        if 'diabetic' in query_lower or 'sugar-free' in query_lower:
            return self._handle_diabetic_query(user_input, entities)
        elif 'pregnant' in query_lower or 'pregnancy' in query_lower:
            return self._handle_pregnancy_query(user_input, entities)
        elif 'wheelchair' in query_lower or 'accessible' in query_lower:
            return self._handle_accessibility_query(user_input, entities)
        else:
            return self._handle_restaurant_query(user_input, entities, None)

    def _handle_diabetic_query(self, user_input: str, entities: Dict) -> str:
        """Handle diabetic and sugar-free dietary needs"""
        return """üçΩÔ∏è **Diabetic-Friendly & Sugar-Free Restaurants**

ü©∫ **Diabetic-Safe Dining Options:**

**1. Zencefil Restaurant**
   Organic vegetarian with sugar-free options
   üìç Location: Galata
   ü•ó Specialty: Fresh salads, sugar-free desserts

**2. Cooklife**
   Health-focused with diabetic-friendly menu
   üìç Location: Bebek, Bomonti
   ‚úÖ Specialty: Sugar-free baked goods, low-carb options

**3. Seasons Restaurant (Four Seasons)**
   Fine dining with medical dietary accommodation
   üìç Location: Sultanahmet
   ‚≠ê Specialty: Custom diabetic-friendly tasting menus

**4. Neolokal**
   Modern Turkish with health-conscious preparations
   üìç Location: Galata
   üçΩÔ∏è Specialty: Fresh, unprocessed Turkish ingredients

**Diabetic-Safe Turkish Foods:**
‚Ä¢ ü•© **Grilled meats** - No sugar marinades
‚Ä¢ ü•ó **Fresh vegetables** - Olive oil preparations
‚Ä¢ üßÄ **Turkish cheese** - Natural, unprocessed
‚Ä¢ ü´í **Olives and nuts** - Healthy snacks
‚Ä¢ ü•¨ **Salads** - Ask for dressing on the side

‚ö†Ô∏è **Foods to Avoid:**
‚Ä¢ Turkish desserts (baklava, k√ºnefe)
‚Ä¢ Sweetened Turkish tea/coffee
‚Ä¢ Fruit juices and sodas
‚Ä¢ Honey-glazed dishes

üí° **Diabetic Dining Tips:**
‚Ä¢ Learn: "≈ûekersiz" (sugar-free) and "Az ≈üekerli" (low sugar)
‚Ä¢ Always ask about hidden sugars in sauces
‚Ä¢ Stick to grilled/steamed preparations
‚Ä¢ Carry glucose meter for monitoring
‚Ä¢ Hotel concierge can help explain dietary needs

ü©∫ Safe and delicious dining for diabetic guests!"""

    def _handle_pregnancy_query(self, user_input: str, entities: Dict) -> str:
        """Handle pregnancy-safe dining options"""
        return """üçΩÔ∏è **Pregnancy-Safe Healthy Restaurants**

ü§± **Pregnancy-Friendly Dining:**

**1. Zencefil Restaurant**
   Organic vegetarian with fresh ingredients
   üìç Location: Galata
   ü•ó Specialty: Organic vegetables, no processed foods

**2. Cooklife**
   Health-focused with fresh preparations
   üìç Location: Bebek, Bomonti
   ‚úÖ Specialty: Fresh juices, wholesome meals

**3. Seasons Restaurant (Four Seasons)**
   High-end dining with quality control
   üìç Location: Sultanahmet
   ‚≠ê Specialty: Premium ingredients, safe preparations

**4. House Cafe**
   Modern cafe with fresh options
   üìç Location: Multiple locations
   ‚òï Specialty: Fresh salads, reliable food safety

**Pregnancy-Safe Turkish Foods:**
‚Ä¢ ü•© **Well-cooked meats** - Avoid rare preparations
‚Ä¢ ü•ó **Fresh vegetables** - Well-washed salads
‚Ä¢ üçû **Fresh bread** - Traditional Turkish bread
‚Ä¢ üßÄ **Pasteurized cheese** - Turkish white cheese
‚Ä¢ üçµ **Herbal teas** - Avoid excessive caffeine

‚ö†Ô∏è **Foods to Avoid:**
‚Ä¢ Raw or undercooked fish
‚Ä¢ Unpasteurized dairy products
‚Ä¢ Raw eggs in preparations
‚Ä¢ Excessive caffeine (Turkish coffee)
‚Ä¢ Unwashed fruits/vegetables

üí° **Pregnancy Dining Tips:**
‚Ä¢ Choose restaurants with good hygiene standards
‚Ä¢ Ask for meat to be well-cooked
‚Ä¢ Avoid street food during pregnancy
‚Ä¢ Drink bottled water
‚Ä¢ Fresh fruit juices are great vitamin sources

ü§± Nutritious and safe dining for expecting mothers!"""

    def _handle_accessibility_query(self, user_input: str, entities: Dict) -> str:
        """Handle wheelchair accessibility and mobility needs"""
        return """üçΩÔ∏è **Wheelchair Accessible Restaurants**

‚ôø **Fully Accessible Dining Options:**

**1. Seasons Restaurant (Four Seasons)**
   5-star hotel with full accessibility
   üìç Location: Sultanahmet
   ‚ôø Features: Wheelchair ramps, accessible restrooms

**2. Mikla Restaurant**
   Modern restaurant with accessibility features
   üìç Location: Beyoƒülu
   üè¢ Features: Elevator access, wide aisles

**3. Sunset Grill & Bar**
   Upscale dining with accessibility
   üìç Location: Ulus
   üåÖ Features: Ground level access, accessible parking

**4. Mall Restaurants (Kanyon, Zorlu Center)**
   Shopping mall dining with full accessibility
   üìç Location: Levent, Be≈üikta≈ü
   üõí Features: Wheelchair access, accessible facilities

**5. Hotel Restaurants**
   Most 4-5 star hotel restaurants are accessible
   üìç Location: Throughout Istanbul
   üè® Features: Ramps, wide doorways, accessible restrooms

**Accessibility Features to Look For:**
‚Ä¢ ‚ôø **Wheelchair ramps** - Entrance access
‚Ä¢ üö™ **Wide doorways** - Easy navigation
‚Ä¢ üöª **Accessible restrooms** - Proper facilities
‚Ä¢ üÖøÔ∏è **Accessible parking** - Close to entrance
‚Ä¢ üõó **Elevator access** - For upper floors

üí° **Accessibility Tips:**
‚Ä¢ Call ahead to confirm accessibility features
‚Ä¢ Hotel restaurants usually have best access
‚Ä¢ Newer restaurants generally more accessible
‚Ä¢ Shopping mall restaurants are reliably accessible
‚Ä¢ Tourist areas have better accessibility compliance

‚ôø Comfortable and accessible dining experiences!"""

    def _detect_user_location(self, user_input: str, user_profile: UserProfile, context: 'ConversationContext') -> Optional[str]:
        """Intelligently detect user's current location using advanced location detection service"""
        
        # Use advanced location detector if available
        if self.advanced_services_available and self.location_detector:
            try:
                result = self.location_detector.detect_location(user_input, user_profile, context)
                
                if result.location:
                    # Update context with detection method and metadata
                    context.set_context('current_detected_location', result.location)
                    context.set_context('location_detection_method', result.detection_method)
                    context.set_context('location_confidence', result.confidence)
                    context.set_context('location_fallbacks', result.fallback_locations)
                    
                    # Update user profile if it's an explicit mention
                    if result.detection_method == 'explicit_query':
                        user_profile.update_location(result.location)
                    
                    logger.info(f"Advanced location detection: {result.location} (method: {result.detection_method}, confidence: {result.confidence})")
                    return result.location
                else:
                    logger.info("Advanced location detector found no definitive location")
                    return None
                    
            except Exception as e:
                logger.warning(f"Advanced location detection failed, falling back to basic detection: {e}")
        
        # Fallback to basic location detection
        return self._detect_user_location_basic(user_input, user_profile, context)

    def _detect_user_location_basic(self, user_input: str, user_profile: UserProfile, context: 'ConversationContext') -> Optional[str]:
        """Basic location detection fallback method"""
        
        # Priority 1: Explicit location mentioned in current query
        entities = self.entity_recognizer.extract_entities(user_input)
        districts = entities.get('districts', [])
        if districts:
            location = districts[0]
            user_profile.update_location(location)  # Update user profile
            context.set_context('current_detected_location', location)
            context.set_context('location_detection_method', 'explicit_query')
            logger.info(f"Location detected from query: {location}")
            return location
        
        # Enhanced contextual location detection for proximity indicators
        proximity_indicators = ['nearby', 'around here', 'close by', 'walking distance', 'in the area']
        if any(indicator in user_input.lower() for indicator in proximity_indicators):
            # Look for most recent location mention in context
            recent_location = self._get_most_recent_location_from_context(context)
            if recent_location:
                context.set_context('current_detected_location', recent_location)
                context.set_context('location_detection_method', 'proximity_inference')
                logger.info(f"Location inferred from proximity indicator: {recent_location}")
                return recent_location
        
        # Priority 2: Check user profile current location
        if user_profile.current_location:
            context.set_context('location_detection_method', 'user_profile')
            logger.info(f"Using user profile location: {user_profile.current_location}")
            return user_profile.current_location
        
        # Priority 3: Check context memory for previous location mentions
        if context.get_context('current_detected_location'):
            location = context.get_context('current_detected_location')
            context.set_context('location_detection_method', 'context_memory')
            logger.info(f"Using context location: {location}")
            return location
        
        # Priority 4: Analyze recent conversation history with weighted recency
        recent_locations = self._extract_locations_from_history_weighted(context.conversation_history)
        if recent_locations:
            # Use most recent or frequently mentioned location with recency bias
            best_location = self._select_best_location_from_history(recent_locations)
            if best_location:
                context.set_context('current_detected_location', best_location)
                context.set_context('location_detection_method', 'conversation_history')
                logger.info(f"Using location from weighted history analysis: {best_location}")
                return best_location
        
        # Priority 5: Check user's favorite neighborhoods with preference weighting
        if user_profile.favorite_neighborhoods:
            # Consider user type and preferences to select best favorite neighborhood
            location = self._select_best_favorite_neighborhood(user_profile)
            context.set_context('location_detection_method', 'favorite_neighborhood')
            logger.info(f"Using selected favorite neighborhood: {location}")
            return location
        
        # Priority 6: Use GPS coordinates if available to determine nearest district
        if user_profile.gps_location:
            nearest_district = self._get_nearest_district_from_gps(user_profile.gps_location)
            if nearest_district:
                context.set_context('location_detection_method', 'gps_coordinates')
                logger.info(f"Using GPS-derived location: {nearest_district}")
                return nearest_district
        
        logger.info("No location detected, will provide general recommendations")
        return None

    def _get_most_recent_location_from_context(self, context: 'ConversationContext') -> Optional[str]:
        """Get the most recently mentioned location from conversation context"""
        # Check last 5 interactions for location mentions
        recent_history = context.conversation_history[-5:] if len(context.conversation_history) > 5 else context.conversation_history
        
        for interaction in reversed(recent_history):  # Start from most recent
            user_input = interaction.get('user_input', '')
            system_response = interaction.get('system_response', '')
            
            # Check user input first
            entities = self.entity_recognizer.extract_entities(user_input)
            districts = entities.get('districts', [])
            if districts:
                return districts[0]
            
            # Check system response for location patterns
            for district in self._get_known_districts():
                if district.lower() in system_response.lower():
                    return district
        
        return None

    def _extract_locations_from_history_weighted(self, conversation_history: List[Dict]) -> List[Dict]:
        """Extract locations from history with recency weighting"""
        weighted_locations = []
        # Look at last 10 interactions with decreasing weight for older interactions
        recent_history = conversation_history[-10:] if len(conversation_history) > 10 else conversation_history
        
        for i, interaction in enumerate(reversed(recent_history)):
            weight = 1.0 - (i * 0.1)  # Recent interactions have higher weight
            user_input = interaction.get('user_input', '')
            system_response = interaction.get('system_response', '')
            
            # Extract from user input
            entities = self.entity_recognizer.extract_entities(user_input)
            districts = entities.get('districts', [])
            for district in districts:
                weighted_locations.append({
                    'location': district,
                    'weight': weight,
                    'source': 'user_input',
                    'interaction_index': len(recent_history) - i - 1
                })
            
            # Extract from system response
            for district in self._get_known_districts():
                if district.lower() in system_response.lower():
                    weighted_locations.append({
                        'location': district,
                        'weight': weight * 0.8,  # System mentions have slightly lower weight
                        'source': 'system_response',
                        'interaction_index': len(recent_history) - i - 1
                    })
        
        return weighted_locations

    def _select_best_location_from_history(self, weighted_locations: List[Dict]) -> Optional[str]:
        """Select the best location from weighted history analysis"""
        if not weighted_locations:
            return None
        
        # Calculate total weight for each location
        location_scores = {}
        for loc_data in weighted_locations:
            location = loc_data['location']
            weight = loc_data['weight']
            
            if location not in location_scores:
                location_scores[location] = {
                    'total_weight': 0,
                    'mention_count': 0,
                    'most_recent_index': -1
                }
            
            location_scores[location]['total_weight'] += weight
            location_scores[location]['mention_count'] += 1
            location_scores[location]['most_recent_index'] = max(
                location_scores[location]['most_recent_index'],
                loc_data['interaction_index']
            )
        
        # Select location with highest combined score (weight + recency + frequency)
        best_location = None
        best_score = 0
        
        for location, score_data in location_scores.items():
            # Combined score: total weight + recency bonus + frequency bonus
            combined_score = (
                score_data['total_weight'] +
                (score_data['most_recent_index'] * 0.1) +  # Recency bonus
                (score_data['mention_count'] * 0.2)  # Frequency bonus
            )
            
            if combined_score > best_score:
                best_score = combined_score
                best_location = location
        
        return best_location

    def _select_best_favorite_neighborhood(self, user_profile: UserProfile) -> str:
        """Select the best favorite neighborhood based on user preferences and context"""
        if not user_profile.favorite_neighborhoods:
            return None
        
        # For now, use first favorite, but could be enhanced with:
        # - User type preferences (tourists prefer tourist areas, locals prefer authentic areas)
        # - Time of day (nightlife areas for evening, business areas for lunch)
        # - Query type (cultural areas for culture queries, food areas for restaurant queries)
        
        primary_favorite = user_profile.favorite_neighborhoods[0]
        
        # Add some intelligence based on user type
        if hasattr(user_profile, 'user_type'):
            if user_profile.user_type == UserType.TOURIST:
                # Tourists might prefer more accessible/famous areas
                tourist_friendly = ['Sultanahmet', 'Taksim', 'Beyoƒülu', 'Galata']
                for neighborhood in user_profile.favorite_neighborhoods:
                    if neighborhood in tourist_friendly:
                        return neighborhood
            elif user_profile.user_type == UserType.LOCAL:
                # Locals might prefer authentic neighborhood experiences
                authentic_areas = ['Kadƒ±k√∂y', 'Be≈üikta≈ü', 'Balat', 'Fener', 'Cihangir']
                for neighborhood in user_profile.favorite_neighborhoods:
                    if neighborhood in authentic_areas:
                        return neighborhood
        
        return primary_favorite

    def _get_known_districts(self) -> List[str]:
        """Get list of known Istanbul districts"""
        return [
            'Sultanahmet', 'Beyoƒülu', 'Galata', 'Taksim', 'Kadƒ±k√∂y', 'Be≈üikta≈ü', 
            '≈ûi≈üli', 'Ni≈üanta≈üƒ±', 'Levent', 'Etiler', 'Ortak√∂y', '√úsk√ºdar',
            'Emin√∂n√º', 'Karak√∂y', 'Cihangir', 'Asmalƒ±mescit', 'Arnavutk√∂y',
            'Bebek', 'Bostancƒ±', 'Fenerbah√ße', 'Moda', 'Balat', 'Fener'
        ]

    def _get_nearest_district_from_gps(self, gps_coords: Dict[str, float]) -> Optional[str]:
        """Determine nearest district from GPS coordinates"""
        lat, lng = gps_coords.get('lat'), gps_coords.get('lng')
        if not lat or not lng:
            return None
        
        # Istanbul district center coordinates (approximate)
        district_coords = {
            'Sultanahmet': {'lat': 41.0086, 'lng': 28.9802},
            'Beyoƒülu': {'lat': 41.0362, 'lng': 28.9773},
            'Taksim': {'lat': 41.0370, 'lng': 28.9850},
            'Kadƒ±k√∂y': {'lat': 40.9833, 'lng': 29.0333},
            'Be≈üikta≈ü': {'lat': 41.0422, 'lng': 29.0097},
            'Galata': {'lat': 41.0256, 'lng': 28.9744},
            'Levent': {'lat': 41.0766, 'lng': 29.0092},
            '≈ûi≈üli': {'lat': 41.0608, 'lng': 28.9866}
        }
        
        min_distance = float('inf')
        nearest_district = None
        
        for district, coords in district_coords.items():
            # Simple distance calculation (Euclidean)
            distance = ((lat - coords['lat'])**2 + (lng - coords['lng'])**2)**0.5
            if distance < min_distance:
                min_distance = distance
                nearest_district = district
        
        return nearest_district

    def _process_with_multi_intent(self, user_input: str, user_profile: UserProfile, context: ConversationContext) -> str:
        """Process message using multi-intent handler with location detector integration"""
        try:
            # PRIORITY CHECK: Neighborhood guide queries should be handled first
            user_input_lower = user_input.lower()
            entities = self.entity_recognizer.extract_entities(user_input)
            matched_districts = []
            
            if self.neighborhood_guide:
                matched_districts = self.neighborhood_guide.find_districts_by_keywords(user_input)
                
                # Enhanced neighborhood detection
                neighborhood_keywords = [
                    'neighborhood', 'district', 'area', 'guide', 'vibe', 'atmosphere', 'character',
                    'compare', 'comparison', 'vs', 'versus', 'which is better',
                    'complete guide', 'comprehensive guide', 'everything about',
                    'besiktas', 'be≈üikta≈ü', 'kadikoy', 'kadƒ±k√∂y', 'sultanahmet', 
                    'sisli', '≈üi≈üli', 'uskudar', '√ºsk√ºdar', 'fatih', 'sariyer', 'sarƒ±yer'
                ]
                
                district_context_keywords = [
                    f"{query_type} in" for query_type in ['restaurants', 'nightlife', 'attractions', 'shopping', 'food', 'bars', 'clubs', 'sights']
                ]
                
                has_neighborhood_context = (
                    any(word in user_input_lower for word in neighborhood_keywords) or
                    any(phrase in user_input_lower for phrase in district_context_keywords) or
                    matched_districts or
                    any(f"in {district}" in user_input_lower for district in ['kadikoy', 'kadƒ±k√∂y', 'besiktas', 'be≈üikta≈ü', 'sultanahmet', 'sisli', '≈üi≈üli', 'uskudar', '√ºsk√ºdar', 'fatih', 'sariyer', 'sarƒ±yer'])
                )
                
                if has_neighborhood_context:
                    logger.info(f"üèòÔ∏è Priority routing to neighborhood guide for query with districts: {matched_districts}")
                    return self._handle_neighborhood_guide_query(user_input, entities, user_profile, context)
            
            # Create context for multi-intent handler
            multi_intent_context = {
                'user_id': user_profile.user_id,
                'session_id': context.session_id,
                'conversation_history': context.get_recent_interactions(5),
                'user_preferences': user_profile.preferences,
                'location': getattr(user_profile, 'current_location', None)
            }
            
            # Analyze query with multi-intent handler
            multi_intent_result = self.multi_intent_handler.analyze_query(user_input, multi_intent_context)
            
            logger.info(f"üéØ Multi-intent analysis: Primary={multi_intent_result.primary_intent.type.value}, "
                       f"Secondary={[i.type.value for i in multi_intent_result.secondary_intents]}")
            
            # Process based on primary intent with location integration
            if multi_intent_result.primary_intent.type.value in ['location_search', 'route_planning']:
                return self._handle_location_intent(user_input, multi_intent_result, user_profile, context)
            elif multi_intent_result.primary_intent.type.value == 'recommendation':
                return self._handle_recommendation_intent(user_input, multi_intent_result, user_profile, context)
            elif multi_intent_result.primary_intent.type.value == 'information_request':
                return self._handle_information_intent(user_input, multi_intent_result, user_profile, context)
            else:
                # Handle other intents or use execution plan
                return self._execute_multi_intent_plan(multi_intent_result, user_profile, context)
            
        except Exception as e:
            logger.error(f"Multi-intent processing failed: {e}")
            return self._process_traditional(user_input, user_profile, context)

    def _handle_location_intent(self, user_input: str, multi_intent_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Handle location-related intents with intelligent location detection"""
        
        # Use intelligent location detector for enhanced location detection
        if self.advanced_services_available and self.location_detector:
            location_result = self.location_detector.detect_location(user_input, user_profile, context)
            
            if location_result:
                # Update context with detected location
                context.set_context('current_detected_location', location_result.location)
                context.set_context('location_confidence', location_result.confidence)
                context.set_context('detection_method', location_result.detection_method)
                
                # Check for transportation context
                if hasattr(location_result, 'context_match') and location_result.context_match:
                    if 'transportation' in location_result.context_match:
                        return self._handle_transportation_query_enhanced(user_input, location_result, user_profile, context)
                
                # Handle regular location search
                return self._handle_location_search_enhanced(user_input, location_result, user_profile, context)
        
        # Fallback to traditional location handling
        entities = self.entity_recognizer.extract_entities(user_input)
        return self._handle_restaurant_query(user_input, entities, user_profile, context)

    def _handle_recommendation_intent(self, user_input: str, multi_intent_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Handle recommendation intents with location awareness"""
        
        # Detect location for recommendation context
        detected_location = None
        if self.advanced_services_available and self.location_detector:
            location_result = self.location_detector.detect_location(user_input, user_profile, context)
            if location_result:
                detected_location = location_result.location
        
        # Extract entities for recommendation processing
        entities = self.entity_recognizer.extract_entities(user_input)
        
        # Update entities with detected location if available
        if detected_location and 'districts' not in entities:
            entities['districts'] = [detected_location]
        
        # Process as enhanced restaurant query
        return self._handle_restaurant_query(user_input, entities, user_profile, context)

    def _handle_information_intent(self, user_input: str, multi_intent_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Handle information requests"""
        
        # Check if it's location-related information
        if any(intent.type.value in ['location_search', 'route_planning'] for intent in multi_intent_result.secondary_intents):
            return self._handle_location_intent(user_input, multi_intent_result, user_profile, context)
        
        # Handle general information requests
        entities = self.entity_recognizer.extract_entities(user_input)
        return self._handle_general_query(user_input, entities, user_profile)

    def _execute_multi_intent_plan(self, multi_intent_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Execute the multi-intent execution plan"""
        
        # For now, return the generated response from multi-intent handler
        if multi_intent_result.response_text:
            return multi_intent_result.response_text
        
        # Fallback to processing primary intent
        entities = self.entity_recognizer.extract_entities("")
        return self._handle_general_query("", entities, user_profile)

    def _handle_transportation_query_enhanced(self, user_input: str, location_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Enhanced transportation query handling with location context"""
        
        transportation_info = f"""üöá **Transportation Information for {location_result.location}**

üìç **Location**: {location_result.location}
üéØ **Detection Method**: {location_result.detection_method}
‚ú® **Confidence**: {location_result.confidence:.1%}

üöä **Transportation Options:**

"""
        
        # Add transportation modes based on location
        if location_result.location in ['Taksim', '≈ûi≈üli', 'Levent']:
            transportation_info += """**Metro**: M2 Metro Line available
**Bus**: Multiple bus routes
**Taxi**: Readily available
**Walking**: Central location, walkable to many areas

"""
        elif location_result.location in ['Sultanahmet', 'Emin√∂n√º']:
            transportation_info += """**Tram**: T1 Tram Line
**Ferry**: Ferry connections from Emin√∂n√º
**Bus**: City bus connections
**Walking**: Historic peninsula, many attractions walkable

"""
        elif location_result.location in ['Kadƒ±k√∂y', '√úsk√ºdar']:
            transportation_info += """**Ferry**: Ferry connections to European side
**Bus**: Extensive bus network
**Metro**: Metro connections available
**Taxi**: Available for cross-city travel

"""
        else:
            transportation_info += """**Mixed Transportation**: Various options available
**Bus**: City bus connections
**Taxi**: Available throughout the city
**Metro/Tram**: Check nearest stations

"""
        
        transportation_info += """üí° **Tips:**
‚Ä¢ Use Istanbul transportation app for real-time schedules
‚Ä¢ Get an Istanbulkart for easy payment
‚Ä¢ Consider traffic when planning your route
‚Ä¢ Ferry connections offer scenic routes"""
        
        return transportation_info

    def _handle_location_search_enhanced(self, user_input: str, location_result, user_profile: UserProfile, context: ConversationContext) -> str:
        """Enhanced location search with intelligent detection results"""
        
        # Build enhanced response with location detection metadata
        entities = self.entity_recognizer.extract_entities(user_input)
        entities['districts'] = [location_result.location]
        
        # Add location confidence to response
        base_response = self._handle_restaurant_query(user_input, entities, user_profile, context)
        
        # Enhance with detection metadata
        location_info = f"\n\nüìç **Location Detection**: {location_result.location} (confidence: {location_result.confidence:.1%})"
        if location_result.fallback_locations:
            location_info += f"\nüîÑ **Alternative areas**: {', '.join(location_result.fallback_locations[:3])}"
        
        return base_response + location_info

    def _process_traditional(self, user_input: str, user_profile: UserProfile, context: ConversationContext) -> str:
        """Traditional processing method as fallback"""
        
        # Extract entities first
        entities = self.entity_recognizer.extract_entities(user_input)
        
        # Use enhanced intent classification for better routing
        primary_intent = self._enhance_intent_classification(user_input)
        
        # Process based on intent with improved routing
        return self._process_by_intent_enhanced(user_input, primary_intent, entities, user_profile)

    def _generate_fallback_response(self, user_input: str) -> str:
        """Generate fallback response when processing fails"""
        return """ü§î I'm having trouble understanding your request right now.

üåü **I can help you with:**
‚Ä¢ üçΩÔ∏è Restaurant recommendations ("restaurants in Kadƒ±k√∂y")
‚Ä¢ üèòÔ∏è Neighborhood guides ("what's Be≈üikta≈ü like?")
‚Ä¢ üé≠ Events and cultural activities
‚Ä¢ üöá Transportation and directions
‚Ä¢ üèõÔ∏è Attractions and sightseeing
‚Ä¢ üí° Local tips and hidden gems

**Try asking:**
‚Ä¢ "Best restaurants in [neighborhood]"
‚Ä¢ "What's the vibe in [district]?"
‚Ä¢ "How to get to [location]?"
‚Ä¢ "What to see in Istanbul?"

Please rephrase your question, and I'll do my best to help! üòä"""
