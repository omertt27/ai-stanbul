"""
Main Istanbul Daily Talk AI System - Simplified and Modular
Enhanced with Production-Grade Infrastructure:
- TTLCache for memory management
- Monitoring and observability
- Error recovery with graceful degradation
"""

import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from ..core.user_profile import UserProfile, UserType
from ..core.conversation_context import ConversationContext
from ..core.entity_recognizer import IstanbulEntityRecognizer
from ..utils.constants import ConversationTone, DEFAULT_RESPONSES

# Import production infrastructure components
try:
    import sys
    import os
    backend_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), 'backend')
    if backend_path not in sys.path:
        sys.path.append(backend_path)
    
    from utils.ttl_cache import TTLCache
    INFRASTRUCTURE_AVAILABLE = True
    logger = logging.getLogger(__name__)
    logger.info("‚úÖ Production infrastructure loaded successfully")
except ImportError as e:
    INFRASTRUCTURE_AVAILABLE = False
    logger = logging.getLogger(__name__)
    logger.warning(f"‚ö†Ô∏è Production infrastructure not available: {e}")

# Configure logger first
logger = logging.getLogger(__name__)

# Import advanced transportation system
try:
    import sys
    import os
    # Add parent directory to path to access transportation modules
    parent_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    if parent_dir not in sys.path:
        sys.path.append(parent_dir)
    
    from enhanced_transportation_integration import TransportationQueryProcessor, create_ml_enhanced_transportation_system, GPSLocation
    ADVANCED_TRANSPORT_AVAILABLE = True
    logger.info("‚úÖ Advanced transportation system loaded successfully")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Advanced transportation system not available: {e}")
    ADVANCED_TRANSPORT_AVAILABLE = False

# Import industry-level routing system
try:
    from services.routing_service_adapter import get_routing_service, RoutingServiceAdapter
    ROUTING_SERVICE_AVAILABLE = True
    logger.info("‚úÖ Industry-level routing service loaded successfully")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Industry-level routing service not available: {e}")
    ROUTING_SERVICE_AVAILABLE = False


class IstanbulDailyTalkAI:
    """
    Production-Grade Istanbul Daily Talk AI System
    
    Enhanced Features:
    - Memory management with TTLCache (prevents memory leaks)
    - Automatic session cleanup
    - LRU eviction policy
    - Production-safe resource handling
    """
    
    def __init__(self):
        self.logger = logger
        self.entity_recognizer = IstanbulEntityRecognizer()
        
        # Use TTLCache for memory management (prevents unbounded growth)
        if INFRASTRUCTURE_AVAILABLE:
            # User profiles: 2-hour TTL, max 1000 users
            self.user_profiles = TTLCache(max_size=1000, ttl_minutes=120)
            # Conversation contexts: 1-hour TTL, max 500 sessions
            self.conversation_contexts = TTLCache(max_size=500, ttl_minutes=60)
            logger.info("‚úÖ Using TTLCache for memory management")
        else:
            # Fallback to regular dicts (not recommended for production)
            self.user_profiles: Dict[str, UserProfile] = {}
            self.conversation_contexts: Dict[str, ConversationContext] = {}
            logger.warning("‚ö†Ô∏è Using unbounded dicts - memory may grow indefinitely")
        
        # Initialize integrations (simplified)
        self._init_integrations()
        
        # Initialize services
        self._init_services()
        
        logger.info("üéâ Enhanced Istanbul Daily Talk AI System initialized (Modular Architecture)")

    def _init_integrations(self):
        """Initialize external integrations"""
        try:
            # Initialize advanced transportation system
            if ADVANCED_TRANSPORT_AVAILABLE:
                self.transport_processor = TransportationQueryProcessor()
                self.ml_transport_system = create_ml_enhanced_transportation_system()
                logger.info("üöá Advanced transportation system with IBB API initialized")
            else:
                self.transport_processor = None
                self.ml_transport_system = None
            
            # Initialize industry-level routing service
            if ROUTING_SERVICE_AVAILABLE:
                self.routing_service = get_routing_service()
                if self.routing_service and self.routing_service.is_initialized:
                    logger.info("üó∫Ô∏è Industry-level routing service initialized successfully")
                else:
                    self.routing_service = None
                    logger.warning("‚ö†Ô∏è Routing service could not be initialized")
            else:
                self.routing_service = None
                
            # Try to load external integrations
            self._load_events_integration()
            self._load_route_integration()
            self._load_deep_learning()
            logger.info("‚úÖ External integrations loaded successfully")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Some integrations not available: {e}")
            self._init_fallback_systems()

    def _load_events_integration(self):
        """Load events integration"""
        try:
            from monthly_events_scheduler import MonthlyEventsScheduler
            self.events_scheduler = MonthlyEventsScheduler()
            self.events_available = True
            logger.info("üé≠ Events integration loaded")
        except ImportError:
            self.events_available = False
            logger.warning("‚ö†Ô∏è Events integration not available")

    def _load_route_integration(self):
        """Load route integration"""
        try:
            from services.route_maker import IstanbulRoutemaker
            self.route_maker = IstanbulRoutemaker()
            self.routing_available = True
            logger.info("üó∫Ô∏è Route integration loaded")
        except ImportError:
            self.routing_available = False
            logger.warning("‚ö†Ô∏è Route integration not available")

    def _load_deep_learning(self):
        """Load deep learning components"""
        try:
            from deep_learning_enhanced_ai import DeepLearningEnhancedAI
            self.deep_learning_ai = DeepLearningEnhancedAI()
            self.deep_learning_available = True
            logger.info("üß† Deep learning integration loaded")
        except ImportError:
            self.deep_learning_available = False
            logger.warning("‚ö†Ô∏è Deep learning not available")

    def _init_fallback_systems(self):
        """Initialize fallback systems when integrations are not available"""
        self.events_available = False
        self.routing_available = False
        self.deep_learning_available = False

    def _init_services(self):
        """Initialize advanced services"""
        # Initialize museum database first
        self.museum_available = False
        self.museum_database = None
        try:
            from accurate_museum_database import get_all_museums
            self.museum_database_data = get_all_museums()
            self.museum_database = type('MuseumDB', (), {'get_all_museums': lambda: self.museum_database_data})()
            self.museum_available = True
            logger.info("üèõÔ∏è Museum Database loaded successfully")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Museum Database not available: {e}")
        
        try:
            from ..services.intelligent_location_detector import IntelligentLocationDetector
            from ..services.gps_location_service import GPSLocationService
            from ..services.neighborhood_guide_service import NeighborhoodGuideService
            
            self.location_detector = IntelligentLocationDetector()
            self.gps_service = GPSLocationService()
            self.neighborhood_guide = NeighborhoodGuideService()
            self.advanced_services_available = True
            logger.info("‚úÖ Advanced location and neighborhood guide services loaded")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Advanced services not available: {e}")
            self.location_detector = None
            self.neighborhood_guide = None
            self.gps_service = None
            self.advanced_services_available = False
        
        # Initialize restaurant handler
        try:
            from ..handlers.enhanced_restaurant_handler import EnhancedRestaurantHandler
            self.restaurant_handler = EnhancedRestaurantHandler()
            self.restaurant_available = True
            logger.info("üçΩÔ∏è Restaurant Recommendation System loaded successfully")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Restaurant Handler not available: {e}")
            self.restaurant_handler = None
            self.restaurant_available = False
        
        # Initialize multi-intent query handler
        try:
            from multi_intent_query_handler import MultiIntentQueryHandler
            self.multi_intent_handler = MultiIntentQueryHandler()
            self.multi_intent_available = True
            logger.info("‚úÖ Multi-Intent Query Handler loaded")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Multi-Intent Query Handler not available: {e}")
            self.multi_intent_handler = None
            self.multi_intent_available = False
        
        # Initialize personality enhancement module
        try:
            from ..services.personality_enhancement import IstanbulPersonality
            self.personality = IstanbulPersonality()
            self.personality_available = True
            logger.info("üé≠ Personality Enhancement Module loaded successfully")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Personality Enhancement not available: {e}")
            self.personality = None
            self.personality_available = False
        
        # Initialize museum database
        try:
            from accurate_museum_database import get_all_museums
            self.museum_database_data = get_all_museums()
            self.museum_database = type('MuseumDB', (), {'get_all_museums': lambda: self.museum_database_data})()
            self.museum_available = True
            logger.info("üèõÔ∏è Museum Database loaded successfully")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Museum Database not available: {e}")
            self.museum_database = None
            self.museum_available = False
        
        # Initialize Response Generation Layer (Week 7-8)
        try:
            from ..response_generation.language_handler import LanguageHandler
            from ..response_generation.context_builder import ContextBuilder
            from ..response_generation.response_formatter import ResponseFormatter
            from ..response_generation.bilingual_responder import BilingualResponder
            from ..response_generation.response_orchestrator import ResponseOrchestrator
            
            self.language_handler = LanguageHandler()
            self.context_builder = ContextBuilder()
            self.response_formatter = ResponseFormatter()
            self.bilingual_responder = BilingualResponder()
            self.response_orchestrator = ResponseOrchestrator(
                language_handler=self.language_handler,
                context_builder=self.context_builder,
                response_formatter=self.response_formatter,
                bilingual_responder=self.bilingual_responder
            )
            self.response_generation_available = True
            logger.info("‚úÖ Response Generation Layer loaded successfully (Week 7-8)")
        except ImportError as e:
            logger.warning(f"‚ö†Ô∏è Response Generation Layer not available: {e}")
            self.response_generation_available = False

    def get_or_create_user_profile(self, user_id: str) -> UserProfile:
        """Get or create user profile - compatible with both TTLCache and dict"""
        if INFRASTRUCTURE_AVAILABLE:
            # Using TTLCache
            profile = self.user_profiles.get(user_id)
            if profile is None:
                profile = UserProfile(user_id=user_id)
                self.user_profiles.set(user_id, profile)
                logger.info(f"Created new user profile for {user_id}")
            return profile
        else:
            # Using regular dict (fallback)
            if user_id not in self.user_profiles:
                self.user_profiles[user_id] = UserProfile(user_id=user_id)
                logger.info(f"Created new user profile for {user_id}")
            return self.user_profiles[user_id]

    def get_or_create_conversation_context(self, session_id: str, user_profile: UserProfile) -> ConversationContext:
        """Get or create conversation context - compatible with both TTLCache and dict"""
        if INFRASTRUCTURE_AVAILABLE:
            # Using TTLCache
            context = self.conversation_contexts.get(session_id)
            if context is None:
                context = ConversationContext(
                    session_id=session_id,
                    user_profile=user_profile
                )
                self.conversation_contexts.set(session_id, context)
            return context
        else:
            # Using regular dict (fallback)
            if session_id not in self.conversation_contexts:
                self.conversation_contexts[session_id] = ConversationContext(
                    session_id=session_id,
                    user_profile=user_profile
                )
            return self.conversation_contexts[session_id]

    def process_message(self, user_input: str, user_id: str, gps_location: Optional[Dict] = None) -> str:
        """
        Main message processing method - enhanced with personality and multi-intent support
        
        Args:
            user_input: User's query text
            user_id: Unique user identifier
            gps_location: Optional GPS location dict with 'latitude', 'longitude', 'name'
        """
        try:
            # Get user profile and context
            user_profile = self.get_or_create_user_profile(user_id)
            session_id = f"session_{user_id}"
            context = self.get_or_create_conversation_context(session_id, user_profile)
            
            # üó∫Ô∏è STEP 1: INTELLIGENT LOCATION DETECTION (Use for all queries)
            detected_location = None
            location_context = {}
            
            if self.advanced_services_available and self.location_detector:
                try:
                    # First, check if GPS location provided
                    if gps_location:
                        location_context['gps_location'] = gps_location
                        detected_location = gps_location.get('name', 'Current Location')
                        logger.info(f"üìç GPS Location provided: {detected_location} ({gps_location.get('latitude')}, {gps_location.get('longitude')})")
                    
                    # Then, detect location from query text (works for "restaurants in Beyoƒülu" etc.)
                    location_result = self.location_detector.detect_location(user_input)
                    if location_result and location_result.get('location'):
                        text_location = location_result.get('location')
                        location_context['text_location'] = text_location
                        if not detected_location:  # Use text location if no GPS
                            detected_location = text_location
                        logger.info(f"üìç Text location detected: {text_location}")
                        
                        # Get neighborhood info if available
                        if location_result.get('coordinates'):
                            location_context['coordinates'] = location_result['coordinates']
                        if location_result.get('district'):
                            location_context['district'] = location_result['district']
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Location detection error: {e}")
            
            # Store location in context for follow-up queries
            if detected_location:
                context.last_location = detected_location
                context.location_context = location_context
            
            # üß† STEP 2: MULTI-INTENT ANALYSIS (Analyze query complexity and intents)
            intent_analysis = None
            is_complex_query = False
            
            if self.multi_intent_available and self.multi_intent_handler:
                try:
                    intent_analysis = self.multi_intent_handler.analyze_query(user_input)
                    if intent_analysis:
                        # Check if this is a multi-intent query (e.g., "museums and restaurants near Taksim")
                        intents_str = str(intent_analysis).lower()
                        intent_count = sum([
                            'museum' in intents_str,
                            'restaurant' in intents_str or 'food' in intents_str,
                            'transport' in intents_str,
                            'event' in intents_str,
                            'attraction' in intents_str
                        ])
                        is_complex_query = intent_count > 1
                        logger.info(f"üß† Intent Analysis: {intent_count} intents detected, Complex: {is_complex_query}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Intent analysis error: {e}")
            
            # üé≠ STEP 3: PERSONALITY ENHANCEMENT: Check for greetings, goodbyes, thanks with warm responses
            # Use new Response Generation Layer if available (Week 7-8)
            if self.response_generation_available and hasattr(self, 'response_orchestrator'):
                # Get language preference from user profile or session (if explicitly set)
                # Don't pass language if not set - let LanguageHandler detect from message content
                user_profile_dict = {}
                if hasattr(user_profile, 'preferences') and 'language' in user_profile.preferences:
                    user_profile_dict['language'] = user_profile.preferences.get('language')
                elif hasattr(user_profile, 'session_context') and 'language' in user_profile.session_context:
                    user_profile_dict['language'] = user_profile.session_context.get('language')
                # If no explicit language preference, leave dict empty - LanguageHandler will detect from message
                
                # Handle greetings
                if self.language_handler.is_greeting(user_input.lower()):
                    response = self.response_orchestrator.generate_response(
                        query=user_input,
                        intent='greeting',
                        user_profile=user_profile_dict if user_profile_dict else None,
                        session_context={'session_id': session_id}
                    )
                    logger.info("üé≠ Response Generation: Greeting handled")
                    return response['text']
                
                # Handle thank you messages
                if self.language_handler.is_thanks(user_input.lower()):
                    response = self.response_orchestrator.generate_response(
                        query=user_input,
                        intent='thanks',
                        user_profile=user_profile_dict if user_profile_dict else None,
                        session_context={'session_id': session_id}
                    )
                    logger.info("üé≠ Response Generation: Thanks handled")
                    return response['text']
                
                # Handle goodbyes
                if self.language_handler.is_goodbye(user_input.lower()):
                    response = self.response_orchestrator.generate_response(
                        query=user_input,
                        intent='goodbye',
                        user_profile=user_profile_dict if user_profile_dict else None,
                        session_context={'session_id': session_id}
                    )
                    logger.info("üé≠ Response Generation: Goodbye handled")
                    return response['text']
            
            # Fallback to personality module if Response Generation Layer not available
            elif self.personality_available and self.personality:
                # Handle greetings
                greeting_response = self.personality.get_greeting(user_input)
                if greeting_response:
                    logger.info("üé≠ Personality: Warm greeting response")
                    return greeting_response
                
                # Handle thank you messages
                if any(word in user_input.lower() for word in ['thank', 'thanks', 'te≈üekk√ºr', 'saƒüol', 'appreciate']):
                    logger.info("üé≠ Personality: Grateful response")
                    return self.personality.handle_thanks(user_input)
                
                # Handle goodbyes
                if any(word in user_input.lower() for word in ['goodbye', 'bye', 'see you', 'g√∂r√º≈ü√ºr√ºz', 'ho≈ü√ßakal', 'cya']):
                    logger.info("üé≠ Personality: Warm goodbye")
                    return self.personality.handle_goodbye(user_input)
            
            # Handle small talk (continue with personality module for now)
            if self.personality_available and self.personality:
                # Handle greetings
                greeting_response = self.personality.get_greeting(user_input)
                if greeting_response:
                    logger.info("üé≠ Personality: Warm greeting response")
                    return greeting_response
                
                # Handle thank you messages
                if any(word in user_input.lower() for word in ['thank', 'thanks', 'te≈üekk√ºr', 'saƒüol', 'appreciate']):
                    logger.info("üé≠ Personality: Grateful response")
                    return self.personality.handle_thanks(user_input)
                
                # Handle goodbyes
                if any(word in user_input.lower() for word in ['goodbye', 'bye', 'see you', 'g√∂r√º≈ü√ºr√ºz', 'ho≈ü√ßakal', 'cya']):
                    logger.info("üé≠ Personality: Warm goodbye")
                    return self.personality.handle_goodbye(user_input)
                
                # Handle small talk - Weather
                if any(word in user_input.lower() for word in ['weather', 'hava', 'rain', 'sunny', 'hot', 'cold']):
                    logger.info("üé≠ Personality: Weather small talk")
                    # Determine weather condition from query
                    weather_condition = 'general'
                    if 'rain' in user_input.lower() or 'rainy' in user_input.lower():
                        weather_condition = 'rainy'
                    elif 'sunny' in user_input.lower() or 'sun' in user_input.lower():
                        weather_condition = 'sunny'
                    elif 'hot' in user_input.lower():
                        weather_condition = 'hot'
                    elif 'cold' in user_input.lower():
                        weather_condition = 'cold'
                    return self.personality.get_weather_talk(weather_condition)
                
                # Handle small talk - Traffic
                if any(word in user_input.lower() for word in ['traffic', 'trafik', 'congestion', 'jam']):
                    logger.info("üé≠ Personality: Traffic small talk")
                    # Determine time context
                    import datetime
                    hour = datetime.datetime.now().hour
                    if 7 <= hour <= 9 or 17 <= hour <= 19:
                        time_context = 'rush_hour'
                    elif hour >= 20 or hour <= 6:
                        time_context = 'evening'
                    else:
                        time_context = 'general'
                    return self.personality.get_traffic_talk(time_context)
                
                # Handle cultural questions
                if any(phrase in user_input.lower() for phrase in ['culture', 'custom', 'tradition', 'etiquette', 'turkish people']):
                    logger.info("üé≠ Personality: Cultural insight")
                    cultural_response = self._handle_cultural_query(user_input)
                    return self.personality.add_personality_to_response(cultural_response, 'cultural')
            
            # üó∫Ô∏è STEP 4A: MUSEUM ROUTE PLANNING - Handle museum tour/route/itinerary requests
            museum_route_keywords = [
                'museum tour', 'museum route', 'museum itinerary', 'museum plan',
                'visit museums', 'museum day', 'museum trip', 'plan my museum',
                'museum walk', 'museums in', 'tour of museums', 'museum hopping',
                'm√ºze turu', 'm√ºze rotasƒ±', 'm√ºze gezisi'
            ]
            
            if any(keyword in user_input.lower() for keyword in museum_route_keywords):
                logger.info(f"üó∫Ô∏è Museum Route Planning: Request detected (Location: {detected_location or 'Not specified'})")
                return self._handle_museum_route_planning(
                    user_input,
                    detected_location,
                    location_context,
                    user_profile,
                    context
                )
            
            # üèõÔ∏è STEP 4B: MUSEUM SYSTEM - Handle museum queries with comprehensive database
            if self.museum_available and self.museum_database:
                museum_keywords = [
                    'museum', 'm√ºze', 'palace', 'saray', 'mosque', 'cami',
                    'topkapi', 'hagia sophia', 'ayasofya', 'blue mosque', 'archaeology',
                    # Contemporary art spaces
                    'contemporary art', 'modern art', 'art gallery', 'exhibition',
                    'arter', 'salt', 'galata', 'dirimart', 'pi artworks', 'mixer',
                    'elgiz', 'akbank sanat', 'borusan', 'art museum', 'contemporary',
                    'gallery', 'sanat', 'galeri', 'sergi'
                ]
                if any(word in user_input.lower() for word in museum_keywords):
                    logger.info(f"üèõÔ∏è Museum System: Processing museum query (Location: {detected_location or 'Not specified'})")
                    museum_response = self._handle_museum_query(user_input, detected_location, location_context)
                    if museum_response:
                        # Add personality touch to museum responses
                        if self.personality_available and self.personality:
                            return self.personality.add_personality_to_response(museum_response, 'informative')
                        return museum_response
            
            # üçΩÔ∏è RESTAURANT SYSTEM: Handle restaurant/food queries with advanced matching
            restaurant_keywords = [
                'restaurant', 'food', 'eat', 'dining', 'restoran', 'yemek',
                'cuisine', 'dish', 'meal', 'breakfast', 'lunch', 'dinner', 
                'brunch', 'cafe', 'cafeteria', 'bistro',
                # Cuisine types
                'turkish', 'ottoman', 'seafood', 'kebab', 'meze', 'baklava',
                'pide', 'lahmacun', 'doner', 'meyhane', 'street food',
                'italian', 'french', 'asian', 'mediterranean', 'international',
                # Dietary
                'vegetarian', 'vegan', 'halal', 'kosher', 'gluten', 'gluten-free',
                'lactose', 'dietary', 'allergy',
                # Price and quality
                'cheap', 'expensive', 'budget', 'luxury', 'affordable',
                # Specific foods
                'balik ekmek', 'simit', 'borek', 'manti', 'kofte', 'dolma'
            ]
            
            if any(word in user_input.lower() for word in restaurant_keywords):
                logger.info(f"üçΩÔ∏è Restaurant System: Processing query (Location: {detected_location or 'Not specified'})")
                
                # ‚úÖ FIX 3.1: TYPO CORRECTION - Correct common typos before processing
                corrected_query, was_corrected = self._correct_restaurant_typos(user_input)
                if was_corrected:
                    logger.info(f"‚úèÔ∏è Typo correction: '{user_input}' ‚Üí '{corrected_query}'")
                    user_input = corrected_query  # Use corrected version
                
                # ‚úÖ FIX 3.2: CONFLICT DETECTION - Check for contradictory requirements
                conflicts = self._detect_query_conflicts(user_input)
                if conflicts:
                    logger.info(f"‚öîÔ∏è Detected {len(conflicts)} query conflict(s)")
                    # Return clarification message about conflicts
                    conflict_response = "üçΩÔ∏è **I want to help you find the perfect restaurant!**\n\n"
                    conflict_response += "I noticed some conflicting preferences in your request:\n\n"
                    for i, conflict in enumerate(conflicts, 1):
                        conflict_response += f"{i}. {conflict['message']}\n\n"
                    conflict_response += "üí° **Let me know your preference, and I'll give you the best recommendations!**"
                    
                    if self.personality_available and self.personality:
                        return self.personality.add_personality_to_response(conflict_response, 'helpful')
                    return conflict_response
                
                # ‚úÖ FIX 3.3: AMBIGUITY DETECTION - Check if query is too vague
                if self._is_ambiguous_restaurant_query(user_input, detected_location):
                    logger.info("‚ùì Ambiguous restaurant query detected - asking for clarification")
                    ambiguous_response = self._handle_ambiguous_restaurant_query(user_input, detected_location)
                    
                    if self.personality_available and self.personality:
                        return self.personality.add_personality_to_response(ambiguous_response, 'helpful')
                    return ambiguous_response
                
                # üß† If multi-intent detected restaurant intent, use it for complex queries
                if is_complex_query and intent_analysis and 'restaurant' in str(intent_analysis).lower():
                    try:
                        logger.info("üß† Multi-Intent Handler: Processing complex restaurant query with location context")
                        multi_response = self.multi_intent_handler.generate_response(intent_analysis, user_input)
                        if multi_response and len(multi_response) > 50:  # Valid response
                            if self.personality_available and self.personality:
                                return self.personality.add_personality_to_response(multi_response, 'helpful')
                            return multi_response
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Multi-intent processing error: {e}")
                
                # üçΩÔ∏è Use dedicated restaurant handler with detected location
                if self.restaurant_available and self.restaurant_handler:
                    try:
                        restaurant_response = self.restaurant_handler.handle_restaurant_query(
                            user_input=user_input,
                            user_profile=user_profile,
                            detected_location=detected_location,
                            location_context=location_context,  # ‚úÖ FIXED: Pass full location context
                            context=context
                        )
                        if restaurant_response:
                            # Add personality touch to restaurant responses
                            if self.personality_available and self.personality:
                                return self.personality.add_personality_to_response(restaurant_response, 'helpful')
                            return restaurant_response
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Restaurant handler error: {e}")
                
                # Final fallback: Generate helpful restaurant response
                return self._generate_restaurant_fallback(user_input, detected_location)
            
            # üöá STEP 6: TRANSPORTATION QUERIES - Use industry-level routing system
            transport_keywords = ['metro', 'bus', 'tram', 'ferry', 'transport', 'how to get', 'direction', 'route',
                                'marmaray', 'metrob√ºs', 'nostalgic tram', 'from', 'to', 'go to', 'travel',
                                'nasƒ±l gidebilirim', 'nasƒ±l giderim', 'ula≈üƒ±m', 'yol', 'aktarma']
            
            if any(word in user_input.lower() for word in transport_keywords):
                logger.info(f"üöá Transportation query detected (Location: {detected_location or 'Not specified'})")
                
                # Priority 1: Try industry-level routing service for route planning
                if self.routing_service and self.routing_service.is_initialized:
                    try:
                        routing_response = self.routing_service.process_routing_query(user_input)
                        if routing_response:
                            logger.info("üó∫Ô∏è Route planned successfully using industry-level routing system")
                            # Add personality touch to routing responses
                            if self.personality_available and self.personality:
                                return self.personality.add_personality_to_response(routing_response, 'helpful')
                            return routing_response
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Routing service error: {e}")
                
                # Priority 2: Use advanced transportation system for general transport info
                if self.transport_processor:
                    try:
                        transport_response = self._handle_transportation_query(user_input, detected_location, location_context)
                        if transport_response:
                            if self.personality_available and self.personality:
                                return self.personality.add_personality_to_response(transport_response, 'helpful')
                            return transport_response
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Advanced transport system error: {e}")
                
                # Fallback: Basic transportation guidance
                return self._generate_transportation_fallback(user_input, detected_location)
            
            # üß† STEP 7: MULTI-INTENT HANDLER - Use for complex multi-category queries
            # Already analyzed at top, now generate response if detected
            if is_complex_query and intent_analysis:
                logger.info("üß† Multi-Intent: Processing complex multi-category query")
                try:
                    response = self.multi_intent_handler.generate_response(intent_analysis, user_input)
                    if response and len(response) > 50:
                        if self.personality_available and self.personality:
                            return self.personality.add_personality_to_response(response, 'helpful')
                        return response
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Multi-intent response generation error: {e}")
            
            # üß† STEP 8: SINGLE-INTENT QUERIES - Use intent analysis for routing
            if intent_analysis and not is_complex_query:
                response = self._process_with_intent_analysis(intent_analysis, user_input, user_profile, context, detected_location, location_context)
            else:
                # Fallback to traditional processing
                response = self._process_traditional(user_input, user_profile, context, detected_location)
            
            # üé≠ PERSONALITY ENHANCEMENT: Add personality touch to all responses
            if self.personality_available and self.personality and response:
                response = self.personality.add_personality_to_response(response, 'general')
            
            # Add to conversation history
            context.add_interaction(user_input, response, "processed")
            
            return response
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            return self._generate_fallback_response(user_input)
    
    def _handle_cultural_query(self, user_input: str) -> str:
        """Handle cultural and etiquette questions with personality"""
        query_lower = user_input.lower()
        
        # Specific cultural topics
        if 'tea' in query_lower or '√ßay' in query_lower:
            return self.personality.get_daily_life_talk('tea_culture')
        elif 'food' in query_lower and 'culture' in query_lower:
            return self.personality.get_daily_life_talk('food_culture')
        elif 'mosque' in query_lower or 'prayer' in query_lower:
            return self.personality.get_cultural_insight('mosque_etiquette')
        elif 'bargain' in query_lower or 'haggle' in query_lower or 'bazaar' in query_lower:
            return self.personality.get_cultural_insight('bargaining')
        elif 'hospitality' in query_lower or 'host' in query_lower:
            return self.personality.get_cultural_insight('hospitality')
        elif 'family' in query_lower:
            return self.personality.get_cultural_insight('family_values')
        elif 'respect' in query_lower or 'polite' in query_lower:
            return self.personality.get_cultural_insight('respect_culture')
        else:
            # General cultural response
            return """üèõÔ∏è **Turkish Culture & Etiquette in Istanbul**

Istanbul is a beautiful blend of Eastern and Western cultures! Here are some key cultural insights:

**Social Customs**:
‚Ä¢ Turkish people are incredibly hospitable - "Misafir Allah'ƒ±n konuƒüudur" (Guests are God's guests!)
‚Ä¢ It's common to be offered √ßay (tea) - accepting is polite and shows respect
‚Ä¢ Greeting with a handshake is common; close friends kiss on both cheeks

**Mosque Etiquette**:
‚Ä¢ Remove shoes before entering (shelves provided)
‚Ä¢ Dress modestly: cover shoulders and knees
‚Ä¢ Ladies should cover their hair (free headscarves at entrance)
‚Ä¢ Be quiet and respectful during prayer times

**Dining Etiquette**:
‚Ä¢ Say "Afiyet olsun!" (Enjoy your meal!) before eating
‚Ä¢ It's polite to try everything offered
‚Ä¢ Sharing food is a sign of friendship

**Shopping Culture**:
‚Ä¢ Bargaining is expected at bazaars (not rude, it's tradition!)
‚Ä¢ Start at 50-60% of asking price
‚Ä¢ It's a social interaction, smile and have fun!

**Daily Life**:
‚Ä¢ Family is very important in Turkish culture
‚Ä¢ Respect for elders is deeply ingrained
‚Ä¢ Public displays of affection are generally modest

Enjoy experiencing Turkish hospitality and culture! üáπüá∑"""
    
    def _handle_museum_query(self, user_input: str, detected_location: Optional[str] = None, location_context: Optional[Dict] = None) -> Optional[str]:
        """
        Handle museum-related queries using the comprehensive museum database
        
        Args:
            user_input: User's query text
            detected_location: Location detected from query or GPS
            location_context: Additional location context (GPS coords, district, etc.)
        """
        query_lower = user_input.lower()
        
        # Get all museums from database
        all_museums = self.museum_database.get_all_museums()
        
        # Specific museum lookup (40+ museums including contemporary art spaces)
        museum_keywords = {
            'hagia sophia': 'hagia_sophia',
            'ayasofya': 'hagia_sophia',
            'topkapi': 'topkapi_palace',
            'topkapƒ±': 'topkapi_palace',
            'blue mosque': 'blue_mosque',
            'sultan ahmed': 'blue_mosque',
            'dolmabahce': 'dolmabahce_palace',
            'dolmabah√ße': 'dolmabahce_palace',
            'archaeology': 'archaeology_museum',
            'archaeological': 'archaeology_museum',
            'galata tower': 'galata_tower',
            'pera': 'pera_museum',
            'istanbul modern': 'istanbul_modern',
            'chora': 'chora_church',
            'kariye': 'chora_church',
            'basilica cistern': 'basilica_cistern',
            'cistern': 'basilica_cistern',
            'beylerbeyi': 'beylerbeyi_palace',
            'rumeli': 'rumeli_fortress',
            'suleymaniye': 'suleymaniye_mosque',
            's√ºleymaniye': 'suleymaniye_mosque',
            # Contemporary Art Museums
            'arter': 'arter',
            'salt galata': 'salt_galata',
            'salt beyoglu': 'salt_beyoglu',
            'salt beyoƒülu': 'salt_beyoglu',
            'dirimart': 'dirimart_dolapdere',
            'pi artworks': 'pi_artworks',
            'mixer': 'mixer',
            'elgiz': 'elgiz_museum',
            'akbank sanat': 'akbank_sanat',
            'borusan': 'borusan_contemporary',
            'borusan contemporary': 'borusan_contemporary'
        }
        
        # Check for specific museum
        for keyword, museum_id in museum_keywords.items():
            if keyword in query_lower:
                museum = all_museums.get(museum_id)
                if museum:
                    return self._format_museum_info(museum)
        
        # Handle general museum queries
        if any(word in query_lower for word in ['list', 'show', 'all', 'museums', 'recommend']):
            # Filter by district if specified
            district_keywords = {
                'sultanahmet': 'Sultanahmet',
                'beyoƒülu': 'Beyoƒülu',
                'beyoglu': 'Beyoƒülu',
                'kadƒ±k√∂y': 'Kadƒ±k√∂y',
                'kadikoy': 'Kadƒ±k√∂y',
                'be≈üikta≈ü': 'Be≈üikta≈ü',
                'besiktas': 'Be≈üikta≈ü',
                'fatih': 'Fatih'
            }
            
            filtered_museums = []
            target_district = None
            
            for keyword, district in district_keywords.items():
                if keyword in query_lower:
                    target_district = district
                    break
            
            if target_district:
                # Filter by district
                for museum_id, museum in all_museums.items():
                    if target_district.lower() in museum.location.lower():
                        filtered_museums.append(museum)
                
                if filtered_museums:
                    return self._format_museum_list(filtered_museums, f"Museums in {target_district}")
            
            # If no district specified, show top recommendations
            top_museums = ['hagia_sophia', 'topkapi_palace', 'blue_mosque', 'dolmabahce_palace', 
                          'archaeology_museum', 'basilica_cistern', 'galata_tower', 'pera_museum']
            recommended = [all_museums[mid] for mid in top_museums if mid in all_museums]
            return self._format_museum_list(recommended, "Top Museum Recommendations")
        
        # Handle opening hours queries
        if any(word in query_lower for word in ['open', 'hours', 'time', 'when']):
            # Try to find which museum they're asking about
            for keyword, museum_id in museum_keywords.items():
                if keyword in query_lower:
                    museum = all_museums.get(museum_id)
                    if museum:
                        hours_info = f"üïê **{museum.name} - Opening Hours**\n\n"
                        for day, hours in museum.opening_hours.items():
                            hours_info += f"**{day.capitalize()}**: {hours}\n"
                        hours_info += f"\nüí∞ **Entrance Fee**: {museum.entrance_fee}\n"
                        hours_info += f"üö™ **Closing Days**: {', '.join(museum.closing_days) if museum.closing_days else 'Open daily'}"
                        return hours_info
        
        # Handle price/fee queries
        if any(word in query_lower for word in ['price', 'fee', 'cost', 'ticket', 'how much']):
            response = "üí∞ **Museum Entrance Fees in Istanbul**\n\n"
            for museum_id in ['hagia_sophia', 'topkapi_palace', 'blue_mosque', 'dolmabahce_palace', 
                             'archaeology_museum', 'basilica_cistern']:
                museum = all_museums.get(museum_id)
                if museum:
                    response += f"‚Ä¢ **{museum.name}**: {museum.entrance_fee}\n"
            response += "\nüí° **Tip**: Many museums offer discounted Museum Pass Istanbul cards!"
            return response
        
        return None
    
    def _format_museum_info(self, museum) -> str:
        """Format detailed museum information"""
        response = f"üèõÔ∏è **{museum.name}**\n\n"
        response += f"üìç **Location**: {museum.location}\n"
        response += f"üìÖ **Period**: {museum.historical_period}\n"
        response += f"üèóÔ∏è **Built**: {museum.construction_date}\n"
        
        if museum.architect:
            response += f"üë∑ **Architect**: {museum.architect}\n"
        
        response += f"\nüí∞ **Entrance Fee**: {museum.entrance_fee}\n"
        response += f"‚è∞ **Best Time to Visit**: {museum.best_time_to_visit}\n"
        response += f"‚è±Ô∏è **Recommended Duration**: {museum.visiting_duration}\n"
        
        response += f"\nüì∏ **Photography**: {'‚úÖ Allowed' if museum.photography_allowed else '‚ùå Not allowed'}\n"
        response += f"‚ôø **Accessibility**: {museum.accessibility}\n"
        
        response += f"\n‚ú® **Historical Significance**:\n{museum.historical_significance}\n"
        
        if museum.must_see_highlights:
            response += f"\nüéØ **Must-See Highlights**:\n"
            for highlight in museum.must_see_highlights[:5]:
                response += f"‚Ä¢ {highlight}\n"
        
        if museum.nearby_attractions:
            response += f"\nüó∫Ô∏è **Nearby Attractions**:\n"
            for attraction in museum.nearby_attractions[:3]:
                response += f"‚Ä¢ {attraction}\n"
        
        return response
    
    def _format_museum_list(self, museums: List, title: str) -> str:
        """Format a list of museums"""
        response = f"üèõÔ∏è **{title}**\n\n"
        response += f"I found {len(museums)} amazing museums for you!\n\n"
        
        for i, museum in enumerate(museums[:8], 1):
            response += f"{i}. **{museum.name}**\n"
            response += f"   üìç {museum.location}\n"
            response += f"   üí∞ {museum.entrance_fee}\n"
            response += f"   ‚è∞ {museum.best_time_to_visit}\n\n"
        
        if len(museums) > 8:
            response += f"\n...and {len(museums) - 8} more museums! Ask about a specific museum for details.\n"
        
        response += "\nüí° Ask me about any specific museum for detailed information!"
        return response
    
    def search_museums(self, query: str) -> List[Dict[str, Any]]:
        """
        Search for museums based on query text.
        Returns list of museum dictionaries with rich metadata for API responses.
        """
        if not self.museum_available or not self.museum_database:
            return []
        
        query_lower = query.lower()
        all_museums = self.museum_database.get_all_museums()
        matching_museums = []
        
        # Search by name, category, or description
        for museum_id, museum in all_museums.items():
            if (query_lower in museum.name.lower() or 
                query_lower in museum.category.lower() or
                query_lower in museum.description.lower() or
                any(query_lower in h.lower() for h in museum.must_see_highlights)):
                
                # Convert museum object to rich dictionary
                museum_dict = {
                    'id': museum_id,
                    'name': museum.name,
                    'type': 'museum',
                    'category': museum.category,
                    'coordinates': [museum.coordinates['lat'], museum.coordinates['lng']],
                    'location': museum.location,
                    'description': museum.description,
                    'highlights': museum.must_see_highlights[:5],
                    'local_tips': [
                        f"Best time: {museum.best_time_to_visit}",
                        f"Visit duration: {museum.visit_duration}",
                        f"Accessibility: {museum.accessibility_info}"
                    ],
                    'opening_hours': self._format_opening_hours(museum.opening_hours),
                    'entrance_fee': museum.entrance_fee,
                    'best_time_to_visit': museum.best_time_to_visit,
                    'visit_duration': museum.visit_duration,
                    'accessibility': museum.accessibility_info,
                    'nearby_transport': ', '.join(museum.how_to_get_there[:2]) if museum.how_to_get_there else 'Public transport available',
                    'nearby_attractions': museum.nearby_attractions[:3],
                    'website': museum.official_website,
                    'phone': museum.phone,
                    'insider_tips': museum.insider_tips[:3]
                }
                matching_museums.append(museum_dict)
        
        # If no matches by content, try category-based search
        if not matching_museums:
            if any(word in query_lower for word in ['art', 'modern', 'contemporary', 'painting']):
                category_filter = 'Art Museum'
            elif any(word in query_lower for word in ['history', 'archaeological', 'ancient']):
                category_filter = 'Historical Museum'
            elif any(word in query_lower for word in ['palace', 'ottoman', 'sultan']):
                category_filter = 'Palace'
            elif any(word in query_lower for word in ['mosque', 'religious', 'islamic']):
                category_filter = 'Mosque'
            else:
                # Return top museums by default
                top_ids = ['hagia_sophia', 'topkapi_palace', 'istanbul_modern', 'pera_museum', 'archaeology_museum']
                for museum_id in top_ids:
                    if museum_id in all_museums:
                        museum = all_museums[museum_id]
                        matching_museums.append(self._museum_to_dict(museum, museum_id))
                return matching_museums[:5]
            
            for museum_id, museum in all_museums.items():
                if category_filter.lower() in museum.category.lower():
                    matching_museums.append(self._museum_to_dict(museum, museum_id))
        
        return matching_museums[:10]  # Return top 10 matches
    
    def _museum_to_dict(self, museum, museum_id: str) -> Dict[str, Any]:
        """Convert museum object to dictionary"""
        return {
            'id': museum_id,
            'name': museum.name,
            'type': 'museum',
            'category': museum.category,
            'coordinates': [museum.coordinates['lat'], museum.coordinates['lng']],
            'location': museum.location,
            'description': museum.description,
            'highlights': museum.must_see_highlights[:5],
            'local_tips': [
                f"Best time: {museum.best_time_to_visit}",
                f"Visit duration: {museum.visit_duration}",
                f"Accessibility: {museum.accessibility_info}"
            ],
            'opening_hours': self._format_opening_hours(museum.opening_hours),
            'entrance_fee': museum.entrance_fee,
            'best_time_to_visit': museum.best_time_to_visit,
            'visit_duration': museum.visit_duration,
            'accessibility': museum.accessibility_info,
            'nearby_transport': ', '.join(museum.how_to_get_there[:2]) if museum.how_to_get_there else 'Public transport available',
            'nearby_attractions': museum.nearby_attractions[:3],
            'website': museum.official_website,
            'phone': museum.phone,
            'insider_tips': museum.insider_tips[:3]
        }
    
    def _format_opening_hours(self, hours_dict: Dict[str, str]) -> str:
        """Format opening hours dictionary to string"""
        if not hours_dict:
            return "Hours vary, please check website"
        
        # Try to find a typical day pattern
        weekday_hours = hours_dict.get('Monday') or hours_dict.get('Tuesday') or hours_dict.get('Wednesday')
        weekend_hours = hours_dict.get('Saturday') or hours_dict.get('Sunday')
        
        if weekday_hours:
            return f"Weekdays: {weekday_hours}" + (f", Weekends: {weekend_hours}" if weekend_hours and weekend_hours != weekday_hours else "")
        
        return "Check website for hours"
    
    @property
    def museum_system(self):
        """Alias for museum_database for backward compatibility with backend"""
        return self.museum_database
    
    def _process_with_intent_analysis(self, intent_analysis: Any, user_input: str, user_profile: UserProfile, 
                                      context: ConversationContext, detected_location: Optional[str] = None,
                                      location_context: Optional[Dict] = None) -> str:
        """
        Process single-intent queries using intent analysis
        Routes to appropriate handler based on detected intent
        """
        try:
            # Use multi-intent handler's response generation
            response = self.multi_intent_handler.generate_response(intent_analysis, user_input)
            if response and len(response) > 50:
                return response
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Intent-based processing error: {e}")
        
        # Fallback if intent processing fails
        return self._process_traditional(user_input, user_profile, context, detected_location)
    
    def _process_traditional(self, user_input: str, user_profile: UserProfile, context: ConversationContext, 
                           detected_location: Optional[str] = None) -> str:
        """Traditional fallback processing with location awareness"""
        location_info = f" in {detected_location}" if detected_location else ""
        return f"I'm here to help you discover Istanbul{location_info}! You can ask me about museums, attractions, restaurants, transportation, events, and more. What would you like to know?"
    
    def _generate_fallback_response(self, user_input: str) -> str:
        """Generate fallback response"""
        return f"I'm your Istanbul AI assistant! I can help you with museums, attractions, restaurants, transportation, and more. What would you like to know about Istanbul?"
    
    def _generate_restaurant_fallback(self, user_input: str, detected_location: Optional[str] = None) -> str:
        """Generate fallback response for restaurant queries when handler is not available"""
        query_lower = user_input.lower()
        
        # Build a helpful response based on query content
        response = "üçΩÔ∏è **Istanbul Dining Recommendations**\n\n"
        
        # Location-specific recommendations
        if detected_location:
            location_lower = detected_location.lower()
            if 'beyoƒülu' in location_lower or 'beyoglu' in location_lower or 'taksim' in location_lower:
                response += f"**Great dining options in {detected_location}**:\n"
                response += "‚Ä¢ **Istiklal Street**: Hundreds of restaurants, cafes, and eateries\n"
                response += "‚Ä¢ **Asmalƒ±mescit**: Famous for meyhanes (Turkish taverns)\n"
                response += "‚Ä¢ **Nevizade Street**: Traditional Turkish cuisine and seafood\n"
            elif 'sultanahmet' in location_lower:
                response += f"**Dining near {detected_location}**:\n"
                response += "‚Ä¢ **Balƒ±k√ßƒ± Sabahattin**: Historic seafood restaurant\n"
                response += "‚Ä¢ **K√∂fteci Selim**: Famous for Turkish meatballs\n"
                response += "‚Ä¢ **Serbethane**: Ottoman cuisine in historic setting\n"
            elif 'kadƒ±k√∂y' in location_lower or 'kadikoy' in location_lower:
                response += f"**Kadƒ±k√∂y food scene** (Asian side):\n"
                response += "‚Ä¢ **√áiya Sofrasƒ±**: Authentic Anatolian cuisine\n"
                response += "‚Ä¢ **Kadƒ±k√∂y Market**: Street food and fresh produce\n"
                response += "‚Ä¢ **Moda cafes**: Trendy brunch spots with sea views\n"
            else:
                response += f"Looking for restaurants in **{detected_location}**?\n"
        
        # Cuisine-specific recommendations
        if any(word in query_lower for word in ['seafood', 'fish', 'balik']):
            response += "\nüêü **Best Seafood Areas**:\n"
            response += "‚Ä¢ **Kumkapƒ±**: Traditional fish restaurants\n"
            response += "‚Ä¢ **Ortak√∂y**: Bosphorus-side dining\n"
            response += "‚Ä¢ **Balƒ±k√ßƒ± Sabahattin**: Historic Sultanahmet restaurant\n"
        
        if any(word in query_lower for word in ['vegetarian', 'vegan']):
            response += "\nü•ó **Vegetarian/Vegan Options**:\n"
            response += "‚Ä¢ **Zencefil**: Popular vegetarian restaurant in Beyoƒülu\n"
            response += "‚Ä¢ **Bi Nevi Deli**: Vegan-friendly organic cafe\n"
            response += "‚Ä¢ Most Turkish restaurants offer excellent meze (vegetarian appetizers)\n"
        
        if any(word in query_lower for word in ['cheap', 'budget', 'affordable']):
            response += "\nüí∞ **Budget-Friendly Options**:\n"
            response += "‚Ä¢ **Simit + √áay**: Traditional breakfast (10-20 TL)\n"
            response += "‚Ä¢ **Lokantas**: Local cafeterias with daily specials (50-100 TL)\n"
            response += "‚Ä¢ **Street food**: D√∂ner, balƒ±k ekmek, midye (20-50 TL)\n"
        
        if any(word in query_lower for word in ['kebab', 'kebap', 'kofte']):
            response += "\nüçñ **Best Kebab Places**:\n"
            response += "‚Ä¢ **Hamdi Restaurant**: Famous for kebabs with Golden Horn views\n"
            response += "‚Ä¢ **Z√ºbeyir Ocakba≈üƒ±**: Traditional grill house in Beyoƒülu\n"
            response += "‚Ä¢ **Sultanahmet K√∂ftecisi**: Historic meatball restaurant\n"
        
        # Add general tips
        response += "\n\nüí° **Dining Tips**:\n"
        response += "‚Ä¢ Try a **Turkish breakfast** (kahvaltƒ±) - it's legendary!\n"
        response += "‚Ä¢ **Meyhanes** are Turkish taverns perfect for evening dining\n"
        response += "‚Ä¢ **Lokantas** offer affordable, home-style Turkish food\n"
        response += "‚Ä¢ Say '**Afiyet olsun!**' (Bon app√©tit!) before eating\n"
        
        return response
    
    def _detect_location_from_query(self, user_input: str) -> Optional[str]:
        """Detect location mentioned in query (fallback method)"""
        query_lower = user_input.lower()
        
        # Common Istanbul districts and neighborhoods
        locations = {
            'beyoƒülu': 'Beyoƒülu',
            'beyoglu': 'Beyoƒülu',
            'taksim': 'Taksim',
            'sultanahmet': 'Sultanahmet',
            'kadƒ±k√∂y': 'Kadƒ±k√∂y',
            'kadikoy': 'Kadƒ±k√∂y',
            'be≈üikta≈ü': 'Be≈üikta≈ü',
            'besiktas': 'Be≈üikta≈ü',
            'ortak√∂y': 'Ortak√∂y',
            'ortakoy': 'Ortak√∂y',
            'emin√∂n√º': 'Emin√∂n√º',
            'eminonu': 'Emin√∂n√º',
            'galata': 'Galata',
            'karak√∂y': 'Karak√∂y',
            'karakoy': 'Karak√∂y',
            'fatih': 'Fatih',
            '√ºsk√ºdar': '√úsk√ºdar',
            'uskudar': '√úsk√ºdar',
            '≈üi≈üli': '≈ûi≈üli',
            'sisli': '≈ûi≈üli',
            'ni≈üanta≈üƒ±': 'Ni≈üanta≈üƒ±',
            'nisantasi': 'Ni≈üanta≈üƒ±'
        }
        
        for key, value in locations.items():
            if key in query_lower:
                return value
        
        return None
    
    def _detect_query_conflicts(self, user_input: str) -> List[Dict[str, str]]:
        """
        Detect conflicting requirements in restaurant queries
        
        Returns:
            List of conflict dictionaries with type and message
        """
        conflicts = []
        query_lower = user_input.lower()
        
        # Price conflicts
        if ('cheap' in query_lower or 'budget' in query_lower or 'affordable' in query_lower) and \
           ('luxury' in query_lower or 'expensive' in query_lower or 'fine dining' in query_lower or 'michelin' in query_lower):
            conflicts.append({
                'type': 'price_conflict',
                'message': "I notice you're looking for both budget-friendly and luxury options. Would you like affordable restaurants with a premium feel, or should I focus on one or the other?"
            })
        
        # Dietary conflicts
        vegan_vegetarian = any(word in query_lower for word in ['vegan', 'vegetarian', 'plant-based', 'veggie'])
        meat_focused = any(word in query_lower for word in ['steakhouse', 'bbq', 'kebab', 'meat', 'steak'])
        
        if vegan_vegetarian and meat_focused:
            conflicts.append({
                'type': 'dietary_conflict',
                'message': "I see you're interested in both vegan/vegetarian options and meat-focused restaurants. Would you like restaurants that offer both options, or are you looking for separate recommendations?"
            })
        
        # Cuisine conflicts
        italian = 'italian' in query_lower
        turkish = any(word in query_lower for word in ['turkish', 'ottoman', 'traditional'])
        authentic = 'authentic' in query_lower
        
        if italian and turkish and authentic:
            conflicts.append({
                'type': 'cuisine_conflict',
                'message': "You mentioned both Italian and Turkish cuisine. Would you like fusion restaurants, or are you looking for two separate recommendations?"
            })
        
        # Ambiance conflicts
        quiet = any(word in query_lower for word in ['quiet', 'peaceful', 'calm', 'silent'])
        live_music = any(word in query_lower for word in ['live music', 'entertainment', 'band', 'performance'])
        
        if quiet and live_music:
            conflicts.append({
                'type': 'ambiance_conflict',
                'message': "You mentioned both quiet atmosphere and live music. Would you like a restaurant with outdoor quiet seating and indoor music, or should I prioritize one?"
            })
        
        # Time conflicts
        breakfast = 'breakfast' in query_lower
        late_night = any(word in query_lower for word in ['late night', 'after midnight', 'late'])
        
        if breakfast and late_night:
            conflicts.append({
                'type': 'time_conflict',
                'message': "Are you looking for a 24/7 restaurant that serves breakfast, or separate breakfast and late-night options?"
            })
        
        return conflicts
    
    def _is_ambiguous_restaurant_query(self, user_input: str, detected_location: Optional[str]) -> bool:
        """
        Check if restaurant query is too ambiguous to provide good recommendations
        
        Returns:
            True if query needs clarification
        """
        query_lower = user_input.lower()
        
        # Very short queries
        word_count = len(query_lower.split())
        if word_count <= 2 and any(word in query_lower for word in ['food', 'restaurant', 'eat', 'dining']):
            return True
        
        # Generic queries without specifics
        generic_patterns = [
            'best food',
            'good place',
            'where to eat',
            'find food',
            'somewhere to eat'
        ]
        
        if any(pattern in query_lower for pattern in generic_patterns):
            # Check if we have any specifics
            has_location = detected_location is not None or any(
                loc in query_lower for loc in ['beyoƒülu', 'beyoglu', 'sultanahmet', 'taksim', 'kadƒ±k√∂y', 'kadikoy']
            )
            has_cuisine = any(
                cuisine in query_lower for cuisine in ['turkish', 'italian', 'seafood', 'kebab', 'pizza', 'sushi']
            )
            has_price = any(
                price in query_lower for price in ['cheap', 'expensive', 'budget', 'luxury', 'affordable']
            )
            has_dietary = any(
                diet in query_lower for diet in ['vegetarian', 'vegan', 'halal', 'kosher', 'gluten']
            )
            
            # If missing most context, it's ambiguous
            specifics_count = sum([has_location, has_cuisine, has_price, has_dietary])
            if specifics_count <= 1:
                return True
        
        return False
    
    def _handle_ambiguous_restaurant_query(self, query: str, detected_location: Optional[str]) -> str:
        """
        Handle ambiguous restaurant queries with helpful clarification prompts
        
        Args:
            query: User's query
            detected_location: Any detected location
            
        Returns:
            Clarification message with helpful prompts
        """
        response = "üçΩÔ∏è **I'd love to help you find the perfect restaurant!**\n\n"
        response += "To give you the best recommendations, could you tell me a bit more?\n\n"
        
        # Ask for missing information
        missing = []
        
        if not detected_location:
            missing.append("üìç **Location**: Which area? (Beyoƒülu, Sultanahmet, Kadƒ±k√∂y, etc.)")
        
        query_lower = query.lower()
        
        # Check for cuisine
        cuisines = ['turkish', 'seafood', 'italian', 'kebab', 'asian', 'french', 'mediterranean']
        if not any(c in query_lower for c in cuisines):
            missing.append("üç≤ **Cuisine**: Turkish, seafood, Italian, vegetarian, etc.?")
        
        # Check for price
        if not any(p in query_lower for p in ['cheap', 'expensive', 'budget', 'luxury', 'affordable']):
            missing.append("üí∞ **Budget**: Budget-friendly, mid-range, or luxury?")
        
        # Check for occasion/mood
        if not any(o in query_lower for o in ['romantic', 'family', 'business', 'casual', 'formal']):
            missing.append("‚ú® **Occasion**: Casual dining, romantic, family-friendly, business?")
        
        # Show what we're missing
        for item in missing[:3]:  # Show top 3 missing items
            response += f"‚Ä¢ {item}\n"
        
        response += "\n**Example queries**:\n"
        response += "‚Ä¢ 'Seafood restaurants in Beyoƒülu'\n"
        response += "‚Ä¢ 'Budget-friendly Turkish food near Taksim'\n"
        response += "‚Ä¢ 'Vegetarian restaurants with Bosphorus view'\n"
        response += "‚Ä¢ 'Romantic Italian restaurant for anniversary'\n"
        
        response += "\nüí° **Or just tell me more about what you're in the mood for!**"
        
        return response
    
    def _correct_restaurant_typos(self, query: str) -> tuple[str, bool]:
        """
        Correct common typos in restaurant queries using fuzzy matching
        
        Returns:
            Tuple of (corrected_query, was_corrected)
        """
        original = query
        corrected = query
        
        # Try importing thefuzz for advanced fuzzy matching
        try:
            from thefuzz import fuzz, process
            FUZZY_AVAILABLE = True
        except ImportError:
            FUZZY_AVAILABLE = False
        
        # Common restaurant terms for fuzzy matching
        restaurant_terms = [
            'restaurant', 'vegetarian', 'seafood', 'halal', 'expensive', 'cheap',
            'budget', 'luxury', 'cuisine', 'traditional', 'modern', 'rooftop',
            'breakfast', 'lunch', 'dinner', 'brunch', 'dessert', 'cafe'
        ]
        
        # Location terms for fuzzy matching
        location_terms = [
            'Beyoƒülu', 'Kadƒ±k√∂y', 'Istanbul', 'Taksim', 'Sultanahmet', 
            'Be≈üikta≈ü', 'Ortak√∂y', 'Emin√∂n√º', 'Galata', 'Uskudar',
            'Sisli', 'Fatih', 'Karakoy', 'Besiktas', 'Bakirkoy'
        ]
        
        # Exact typo corrections (fast path)
        typo_corrections = {
            'restourant': 'restaurant',
            'resturant': 'restaurant',
            'restraunt': 'restaurant',
            'restarant': 'restaurant',
            'vegiterian': 'vegetarian',
            'vegeterian': 'vegetarian',
            'seafod': 'seafood',
            'halaal': 'halal',
            'were to': 'where to',
            'were can': 'where can',
            'expensiv': 'expensive',
            'beyoglu': 'Beyoƒülu',
            'kadikoy': 'Kadƒ±k√∂y',
            'istambul': 'Istanbul',
            'constantinople': 'Istanbul',
            'taxim': 'Taksim',
            'taksim square': 'Taksim',
            'sultanahmed': 'Sultanahmet',
            'besiktas': 'Be≈üikta≈ü',
            'ortakoy': 'Ortak√∂y',
            'eminonu': 'Emin√∂n√º'
        }
        
        # Fast exact matching first
        import re
        query_lower = corrected.lower()
        for typo, correct in typo_corrections.items():
            if typo in query_lower:
                pattern = re.compile(re.escape(typo), re.IGNORECASE)
                corrected = pattern.sub(correct, corrected)
        
        # Fuzzy matching for remaining terms (if available)
        if FUZZY_AVAILABLE:
            words = corrected.split()
            corrected_words = []
            
            for word in words:
                word_lower = word.lower().strip('.,!?')
                corrected_word = word
                
                # Skip short words and already corrected words
                if len(word_lower) < 4:
                    corrected_words.append(word)
                    continue
                
                # Check restaurant terms
                best_match = process.extractOne(word_lower, restaurant_terms, scorer=fuzz.ratio)
                if best_match and best_match[1] >= 80:  # 80% similarity threshold
                    if best_match[1] < 100:  # Only if not exact match
                        corrected_word = best_match[0]
                        self.logger.debug(f"Fuzzy corrected '{word}' to '{corrected_word}' (score: {best_match[1]})")
                
                # Check location terms if no restaurant match
                if corrected_word == word:
                    best_match = process.extractOne(word_lower, location_terms, scorer=fuzz.ratio)
                    if best_match and best_match[1] >= 80:
                        if best_match[1] < 100:
                            corrected_word = best_match[0]
                            self.logger.debug(f"Fuzzy corrected location '{word}' to '{corrected_word}' (score: {best_match[1]})")
                
                corrected_words.append(corrected_word)
            
            corrected = ' '.join(corrected_words)
        
        was_corrected = (corrected != original)
        if was_corrected:
            self.logger.info(f"üîß Typo correction: '{original}' -> '{corrected}'")
        
        return corrected, was_corrected
    
    def _handle_transportation_query(self, user_input: str, detected_location: Optional[str] = None, 
                                     location_context: Optional[Dict] = None) -> Optional[str]:
        """
        Handle transportation queries using advanced transport system
        
        Args:
            user_input: User's query text
            detected_location: Location detected from query or GPS
            location_context: Additional location context (GPS coords, district, etc.)
        
        Returns:
            Transportation response or None if not available
        """
        if not self.transport_processor:
            return None
        
        try:
            # Use the advanced transportation system for general info
            query_lower = user_input.lower()
            
            # Build response based on query type
            response_parts = []
            
            # General transport info queries
            if any(word in query_lower for word in ['how does', 'how do i use', 'explain', 'what is', 'tell me about']):
                if 'metro' in query_lower:
                    response_parts.append("üöá **Istanbul Metro System**\n")
                    response_parts.append("Istanbul has an extensive metro network covering both European and Asian sides:\n\n")
                    response_parts.append("**Major Lines:**")
                    response_parts.append("‚Ä¢ **M1** (Red): Airport - Yenikapƒ± - Kirazlƒ±")
                    response_parts.append("‚Ä¢ **M2** (Green): Yenikapƒ± - Hacƒ±osman (connects to Marmaray)")
                    response_parts.append("‚Ä¢ **M3** (Blue): Kirazlƒ± - Olimpiyat - Ba≈üak≈üehir")
                    response_parts.append("‚Ä¢ **M4** (Pink): Kadƒ±k√∂y - Tav≈üantepe (Asian side)")
                    response_parts.append("‚Ä¢ **M5** (Purple): √úsk√ºdar - √áekmek√∂y (Asian side)")
                    response_parts.append("‚Ä¢ **M6** (Brown): Levent - Hisar√ºst√º")
                    response_parts.append("‚Ä¢ **M7** (Light Blue): Mecidiyek√∂y - Mahmutbey")
                    response_parts.append("\nüí≥ **Payment:** Use Istanbul Card (Istanbulkart)")
                    response_parts.append("üí∞ **Cost:** Single ride ~‚Ç∫15-20 (with discount card)")
                    
                elif 'marmaray' in query_lower:
                    response_parts.append("üöÑ **Marmaray Rail System**\n")
                    response_parts.append("The first rail tunnel connecting Europe and Asia!\n\n")
                    response_parts.append("**Route:** Halkalƒ± (Europe) ‚Üî Gebze (Asia)")
                    response_parts.append("**Key Stops:** Halkalƒ±, Bakƒ±rk√∂y, Yenikapƒ±, Sirkeci, Ayrƒ±lƒ±k√ße≈ümesi, √úsk√ºdar, Kadƒ±k√∂y, Gebze")
                    response_parts.append("\n**Connections:**")
                    response_parts.append("‚Ä¢ Metro M2 at Yenikapƒ±")
                    response_parts.append("‚Ä¢ Metro M4 at Ayrƒ±lƒ±k√ße≈ümesi")
                    response_parts.append("‚Ä¢ Metrob√ºs at multiple stations")
                    response_parts.append("\n‚è±Ô∏è **Frequency:** Every 3-15 minutes depending on time")
                    response_parts.append("üí∞ **Cost:** Same as metro (~‚Ç∫15-20)")
                
                elif 'bus' in query_lower or 'otob√ºs' in query_lower:
                    response_parts.append("üöå **Istanbul Bus System**\n")
                    response_parts.append("Extensive bus network covering all neighborhoods:\n\n")
                    response_parts.append("**Types:**")
                    response_parts.append("‚Ä¢ **IETT Buses:** Main public buses (red)")
                    response_parts.append("‚Ä¢ **Metrob√ºs:** Rapid transit buses on dedicated lanes")
                    response_parts.append("‚Ä¢ **Private Buses:** Yellow and white buses")
                    response_parts.append("\nüí≥ **Payment:** Istanbul Card required")
                    response_parts.append("üí∞ **Cost:** ~‚Ç∫15 per ride")
                    response_parts.append("\nüì± **Tip:** Use Istanbul public transport apps for real-time info!")
                
                elif 'ferry' in query_lower or 'vapur' in query_lower:
                    response_parts.append("‚õ¥Ô∏è **Istanbul Ferry System**\n")
                    response_parts.append("Experience Istanbul by sea!\n\n")
                    response_parts.append("**Main Routes:**")
                    response_parts.append("‚Ä¢ Emin√∂n√º ‚Üî Kadƒ±k√∂y (Most popular)")
                    response_parts.append("‚Ä¢ Karak√∂y ‚Üî Kadƒ±k√∂y")
                    response_parts.append("‚Ä¢ Be≈üikta≈ü ‚Üî √úsk√ºdar")
                    response_parts.append("‚Ä¢ Bosphorus tours (Emin√∂n√º - Princes' Islands)")
                    response_parts.append("\nüí≥ **Payment:** Istanbul Card or token")
                    response_parts.append("üí∞ **Cost:** ~‚Ç∫15-25 depending on route")
                    response_parts.append("‚è±Ô∏è **Duration:** 15-25 minutes for short crossings")
                    response_parts.append("\nüåÖ **Tip:** Best views during sunset!")
            
            if response_parts:
                return "\n".join(response_parts)
            
            # If no specific info query, return None to try routing
            return None
            
        except Exception as e:
            logger.error(f"Error in transportation query handler: {e}")
            return None
    
    def _generate_transportation_fallback(self, user_input: str, detected_location: Optional[str] = None) -> str:
        """
        Generate fallback response for transportation queries
        
        Args:
            user_input: User's query text
            detected_location: Location detected from query or GPS
        
        Returns:
            Helpful transportation fallback response
        """
        response_parts = []
        response_parts.append("üöá **Istanbul Public Transportation**\n")
        
        if detected_location:
            response_parts.append(f"Getting around {detected_location}:\n")
        
        response_parts.append("\n**Transportation Options:**")
        response_parts.append("‚Ä¢ üöá **Metro:** Fast, modern, covers major districts")
        response_parts.append("‚Ä¢ üöÑ **Marmaray:** Connects Europe and Asia under the Bosphorus")
        response_parts.append("‚Ä¢ üöå **Buses:** Extensive network, IETT and Metrob√ºs")
        response_parts.append("‚Ä¢ üöä **Trams:** Historic and modern lines (Istiklal, Sultanahmet)")
        response_parts.append("‚Ä¢ ‚õ¥Ô∏è **Ferries:** Scenic Bosphorus crossings")
        response_parts.append("‚Ä¢ üöï **Taxis:** Yellow cabs and ride-sharing apps")
        
        response_parts.append("\nüí≥ **Istanbul Card (Istanbulkart):**")
        response_parts.append("Essential for public transport! Available at kiosks and machines.")
        response_parts.append("Offers discounted fares and easy transfers.")
        
        response_parts.append("\nüí° **Tips:**")
        response_parts.append("‚Ä¢ Download ƒ∞BB mobile app for real-time schedules")
        response_parts.append("‚Ä¢ Peak hours: 7-9 AM, 5-7 PM (can be crowded)")
        response_parts.append("‚Ä¢ Most lines run 6 AM - 12 AM")
        
        response_parts.append("\nüó∫Ô∏è **For specific route planning:**")
        response_parts.append("Ask me: 'How do I get from [origin] to [destination]?'")
        response_parts.append("Example: 'How do I get from Taksim to Kadƒ±k√∂y?'")
        
        return "\n".join(response_parts)
    
    def _handle_museum_route_planning(
        self,
        user_input: str,
        detected_location: Optional[str],
        location_context: Dict,
        user_profile,
        context
    ) -> str:
        """
        Handle museum route planning requests with map visualization
        
        Creates optimized museum tours with:
        - Duration-based planning (short/standard/long)
        - District filtering
        - Interactive map visualization
        - Walking directions between museums
        """
        import asyncio
        from museum_route_map_generator import MuseumRouteMapGenerator
        
        logger.info("üó∫Ô∏è Processing museum route planning request")
        
        try:
            # Initialize museum route planner if available
            if not hasattr(self, 'museum_route_planner'):
                # Try to load the planner
                try:
                    from enhanced_museum_route_planner import EnhancedMuseumRoutePlanner
                    self.museum_route_planner = EnhancedMuseumRoutePlanner()
                    logger.info("‚úÖ Museum route planner initialized")
                except ImportError as e:
                    logger.warning(f"‚ö†Ô∏è Museum route planner not available: {e}")
                    return self._museum_route_fallback(user_input, detected_location)
            
            # Parse user requirements
            duration = self._extract_duration_from_query(user_input)
            district = self._extract_district_from_query(user_input, detected_location)
            interests = self._extract_interests_from_query(user_input)
            tour_type = self._determine_tour_type(duration)
            max_museums = self._get_museum_count_for_duration(duration)
            
            logger.info(f"üìä Route params: duration={duration}h, district={district}, interests={interests}, type={tour_type}")
            
            # Build preferences for route planner
            preferences = {
                'interests': interests,
                'max_museums': max_museums,
                'budget_tl': 1000,  # Default budget
                'accessibility_needed': False,
                'duration_hours': duration
            }
            
            # Add location filter (check if it's a neighborhood or district)
            if district:
                # Neighborhoods that aren't districts
                neighborhoods = ['Sultanahmet', 'Taksim', 'Galata', 'Karak√∂y', 'Ortak√∂y', 'Emin√∂n√º']
                if district in neighborhoods:
                    preferences['neighborhoods'] = [district]
                else:
                    preferences['districts'] = [district]
            
            # Create museum route (handle async properly)
            import concurrent.futures
            import threading
            
            def run_async_route():
                """Run async route planning in separate thread with own event loop"""
                new_loop = asyncio.new_event_loop()
                asyncio.set_event_loop(new_loop)
                try:
                    result = new_loop.run_until_complete(
                        self.museum_route_planner.create_museum_route(preferences, duration_hours=duration)
                    )
                    return result
                finally:
                    new_loop.close()
            
            # Execute in thread pool to avoid event loop conflicts
            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
                future = executor.submit(run_async_route)
                try:
                    route = future.result(timeout=15)
                except concurrent.futures.TimeoutError:
                    logger.error("Museum route planning timed out")
                    return self._museum_route_fallback(user_input, detected_location)
                except Exception as e:
                    logger.error(f"Error in async execution: {e}")
                    return self._museum_route_fallback(user_input, detected_location)
            
            if not route or not route.get('museums'):
                logger.warning("No museums in route, using fallback")
                return self._museum_route_fallback(user_input, detected_location)
            
            # Generate map visualization
            map_generator = MuseumRouteMapGenerator()
            
            # Create text response
            response = self._format_museum_route_response(route, tour_type, district)
            
            # Note: In production, we would save the map HTML and return a URL
            # For now, we'll include the map details in the response
            # You can uncomment the lines below to save the map
            
            # map_html = map_generator.create_interactive_map(route)
            # map_url = self._save_and_get_map_url(map_html, context.session_id)
            # response += f"\n\nüó∫Ô∏è **Interactive Map:** {map_url}"
            
            google_maps_url = map_generator.create_google_maps_url(route.get('museums', []))
            if google_maps_url:
                response += f"\n\nüó∫Ô∏è **View Route on Google Maps:** [Open Map]({google_maps_url})"

            return response
            
        except Exception as e:
            logger.error(f"Error in museum route planning: {e}", exc_info=True)
            return self._museum_route_fallback(user_input, detected_location)
    
    def _extract_duration_from_query(self, query: str) -> float:
        """Extract duration in hours from query"""
        import re
        
        query_lower = query.lower()
        
        # Look for explicit hour mentions
        hour_patterns = [
            r'(\d+)\s*hour',
            r'(\d+)\s*hr',
            r'(\d+)h',
            r'(\d+)\s*saat'
        ]
        
        for pattern in hour_patterns:
            match = re.search(pattern, query_lower)
            if match:
                return float(match.group(1))
        
        # Look for time-of-day mentions
        if any(word in query_lower for word in ['morning', 'sabah', 'half day', 'yarƒ±m g√ºn']):
            return 4.0
        elif any(word in query_lower for word in ['afternoon', '√∂ƒüleden sonra']):
            return 5.0
        elif any(word in query_lower for word in ['full day', 'whole day', 't√ºm g√ºn', 'b√ºt√ºn g√ºn']):
            return 8.0
        elif any(word in query_lower for word in ['quick', 'short', 'brief', 'kƒ±sa']):
            return 3.0
        elif any(word in query_lower for word in ['long', 'extended', 'uzun']):
            return 7.0
        
        # Default to standard tour
        return 5.0
    
    def _extract_district_from_query(self, query: str, detected_location: Optional[str]) -> Optional[str]:
        """Extract district or neighborhood from query"""
        query_lower = query.lower()
        
        # Map neighborhoods to their actual districts or use neighborhood name
        # EnhancedMuseumRoutePlanner filters by both district AND neighborhood
        location_mapping = {
            # Neighborhoods ‚Üí Keep as is (planner handles both)
            'sultanahmet': 'Sultanahmet',  # Will be used as neighborhood filter
            'taksim': 'Taksim',
            'galata': 'Galata',
            'karak√∂y': 'Karak√∂y',
            'karakoy': 'Karak√∂y',
            'ortak√∂y': 'Ortak√∂y',
            'ortakoy': 'Ortak√∂y',
            'emin√∂n√º': 'Emin√∂n√º',
            'eminonu': 'Emin√∂n√º',
            # Districts
            'beyoƒülu': 'Beyoƒülu',
            'beyoglu': 'Beyoƒülu',
            'be≈üikta≈ü': 'Be≈üikta≈ü',
            'besiktas': 'Be≈üikta≈ü',
            'kadƒ±k√∂y': 'Kadƒ±k√∂y',
            'kadikoy': 'Kadƒ±k√∂y',
            '√ºsk√ºdar': '√úsk√ºdar',
            'uskudar': '√úsk√ºdar',
            'fatih': 'Fatih',
            '≈üi≈üli': '≈ûi≈üli',
            'sisli': '≈ûi≈üli',
            'sarƒ±yer': 'Sarƒ±yer',
            'sariyer': 'Sarƒ±yer'
        }
        
        # Priority 1: Use detected location
        if detected_location:
            detected_lower = detected_location.lower()
            return location_mapping.get(detected_lower, detected_location)
        
        # Priority 2: Look for location mentions in query
        for key, value in location_mapping.items():
            if key in query_lower:
                return value
        
        return None
    
    def _extract_interests_from_query(self, query: str) -> List[str]:
        """Extract interests from query"""
        query_lower = query.lower()
        interests = []
        
        interest_keywords = {
            'history': ['history', 'historical', 'tarih', 'tarihi'],
            'art': ['art', 'sanat', 'painting', 'sculpture'],
            'culture': ['culture', 'k√ºlt√ºr', 'cultural', 'k√ºlt√ºrel'],
            'archaeology': ['archaeology', 'arkeoloji', 'ancient', 'antik'],
            'contemporary': ['contemporary', 'modern', '√ßaƒüda≈ü']
        }
        
        for interest, keywords in interest_keywords.items():
            if any(keyword in query_lower for keyword in keywords):
                interests.append(interest)
        
        # Default to general if no specific interest found
        if not interests:
            interests = ['history', 'art']
        
        return interests
    
    def _determine_tour_type(self, duration: float) -> str:
        """Determine tour type based on duration"""
        if duration <= 3:
            return "short"
        elif duration <= 5:
            return "standard"
        else:
            return "long"
    
    def _get_museum_count_for_duration(self, duration: float) -> int:
        """Get recommended museum count for duration"""
        if duration <= 3:
            return 2
        elif duration <= 5:
            return 3
        elif duration <= 7:
            return 4
        else:
            return 5
    
    def _format_museum_route_response(
        self,
        route: Dict[str, Any],
        tour_type: str,
        district: Optional[str]
    ) -> str:
        """Format museum route response with all details"""
        museums = route.get('museums', [])
        
        response = f"üó∫Ô∏è **Your {tour_type.title()} Museum Tour"
        if district:
            response += f" in {district}"
        response += "**\n\n"
        
        # Summary statistics
        response += "üìä **Tour Summary:**\n"
        response += f"‚Ä¢ üèõÔ∏è Museums: {len(museums)}\n"
        response += f"‚Ä¢ ‚è±Ô∏è Duration: {route.get('total_duration_hours', 0):.1f} hours\n"
        response += f"‚Ä¢ üí∞ Total Cost: {route.get('total_cost_tl', 0):.0f} TL\n"
        response += f"‚Ä¢ üö∂ Walking: {route.get('total_walking_distance_km', 0):.1f} km\n\n"
        
        # Detailed itinerary
        response += "üéØ **Detailed Itinerary:**\n\n"
        
        for i, museum_info in enumerate(museums, 1):
            museum = museum_info.get('museum')
            if not museum:
                continue
            
            response += f"**{i}. {museum.name}**\n"
            response += f"üìç {museum.district} - {museum.neighborhood}\n"
            response += f"üïí Arrival: {museum_info.get('arrival_time', 'N/A')}\n"
            response += f"‚è±Ô∏è Visit Duration: {museum.visit_duration_minutes} minutes\n"
            response += f"üí∞ Entry Fee: {museum.entry_fee_tl} TL\n"
            
            # Top highlights
            if hasattr(museum, 'highlights') and museum.highlights:
                response += f"‚ú® **Don't Miss:** {museum.highlights[0]}\n"
            
            # Top local tip
            if hasattr(museum, 'local_tips') and museum.local_tips:
                top_tips = [tip for tip in museum.local_tips if tip.importance >= 4]
                if top_tips:
                    response += f"üí° **Local Tip:** {top_tips[0].description}\n"
            
            # Walking distance to next
            if i < len(museums):
                walking_dist = museum_info.get('walking_distance', None)
                if walking_dist:
                    response += f"üö∂ Walk to next: {walking_dist}\n"
            
            response += "\n"
        
        # Additional tips
        response += "üí° **Smart Tips:**\n"
        response += "‚Ä¢ Start early to avoid crowds (9 AM recommended)\n"
        response += "‚Ä¢ Get the Museum Pass Istanbul for discounts\n"
        response += "‚Ä¢ Wear comfortable walking shoes\n"
        response += "‚Ä¢ Bring water and snacks\n"
        
        return response
    
    def _museum_route_fallback(self, query: str, location: Optional[str]) -> str:
        """Fallback response when route planning fails"""
        response = "üó∫Ô∏è **Museum Tour Planning**\n\n"
        response += "I can help you plan a perfect museum tour! Here are some popular options:\n\n"
        
        if location and 'sultanahmet' in location.lower():
            response += "**Sultanahmet Historical Tour (5-6 hours):**\n"
            response += "1. Hagia Sophia (90 min) - 200 TL\n"
            response += "2. Topkapi Palace (120 min) - 200 TL\n"
            response += "3. Istanbul Archaeological Museums (90 min) - 100 TL\n"
            response += "4. Turkish & Islamic Arts Museum (60 min) - 100 TL\n\n"
        elif location and 'beyoƒülu' in location.lower():
            response += "**Beyoƒülu Art & Culture Tour (4-5 hours):**\n"
            response += "1. Pera Museum (90 min) - 150 TL\n"
            response += "2. Istanbul Modern (120 min) - 200 TL\n"
            response += "3. SALT Galata (60 min) - Free\n"
            response += "4. Arter (90 min) - 80 TL\n\n"
        else:
            response += "**Classic Istanbul Museum Tour (Full Day):**\n"
            response += "‚Ä¢ Morning: Hagia Sophia + Topkapi Palace (Sultanahmet)\n"
            response += "‚Ä¢ Afternoon: Archaeological Museums + Basilica Cistern\n"
            response += "‚Ä¢ Total Cost: ~600 TL | Duration: 6-7 hours\n\n"
        
        response += "üí° **Tell me:**\n"
        response += "‚Ä¢ How many hours do you have? (e.g., '4 hours', 'half day', 'full day')\n"
        response += "‚Ä¢ Which district? (e.g., 'Sultanahmet', 'Beyoƒülu', 'Kadƒ±k√∂y')\n"
        response += "‚Ä¢ What interests you? (e.g., 'history', 'art', 'archaeology')\n\n"
        response += "Example: 'Plan a 5-hour art museum tour in Beyoƒülu'"
        
        return response
