    off_route: bool = False    rerouting: bool = False    has_arrived: bool = False    warnings: List[str] = field(default_factory=list)class GPSNavigationEngine:    """    Real-time GPS navigation engine with turn-by-turn directions    """        # Announcement distances for different modes (meters)    ANNOUNCEMENT_DISTANCES = {        NavigationMode.WALKING: {            'prepare': 50,    # "In 50 meters..."            'imminent': 20,   # "Turn right soon"            'immediate': 5     # "Turn right now"        },        NavigationMode.CYCLING: {            'prepare': 100,            'imminent': 30,            'immediate': 10        },        NavigationMode.DRIVING: {            'prepare': 500,            'imminent': 100,            'immediate': 20        },        NavigationMode.TRANSIT: {            'prepare': 100,            'imminent': 50,            'immediate': 10        }    }        # Off-route threshold (meters)    OFF_ROUTE_THRESHOLD = 50  # 50 meters from planned route        def __init__(        self,        route_steps: List[RouteStep],        mode: NavigationMode = NavigationMode.WALKING,        language: str = "en"    ):        """        Initialize GPS navigation engine                Args:            route_steps: List of steps in the route            mode: Navigation mode (walking, cycling, driving)            language: Language for instructions (en, tr)        """        self.route_steps = route_steps        self.mode = mode        self.language = language                self.current_step_index = 0        self.start_time = None        self.start_location = None        self.destination = route_steps[-1].end_location if route_steps else None                self.is_navigating = False        self.has_arrived = False        self.off_route_count = 0                self.location_history: List[GPSLocation] = []        self.instruction_history: List[NavigationInstruction] = []                logger.info(f"âœ… GPS Navigation initialized with {len(route_steps)} steps")        def start_navigation(self, start_location: GPSLocation) -> NavigationState:        """        Start navigation from given location                Args:            start_location: Current GPS location                    Returns:            Initial navigation state        """        self.is_navigating = True        self.start_time = datetime.now()        self.start_location = start_location        self.current_step_index = 0        self.has_arrived = False                self.location_history.append(start_location)                logger.info(f"ðŸ§­ Navigation started from {start_location.coordinates}")                # Generate first instruction        return self.update_location(start_location)        def update_location(self, location: GPSLocation) -> NavigationState:        """        Update current location and get navigation state                Args:            location: Current GPS location                    Returns:            Updated navigation state with current instructions        """        if not self.is_navigating:            raise ValueError("Navigation not started. Call start_navigation() first.")                self.location_history.append(location)                # Check if arrived at destination        if self._check_arrival(location):            self.has_arrived = True            self.is_navigating = False            return self._create_arrival_state(location)                # Check if off route        off_route = self._check_off_route(location)                if off_route:            self.off_route_count += 1            logger.warning(f"âš ï¸ Off route detected ({self.off_route_count} times)")        else:            self.off_route_count = 0                # Update current step based on progress        self._update_current_step(location)                # Generate instructions        current_instruction = self._generate_current_instruction(location)        next_instruction = self._generate_next_instruction()                # Calculate progress        progress = self._calculate_progress(location)                # Create state        state = NavigationState(            current_location=location,            current_instruction=current_instruction,            next_instruction=next_instruction,            progress=progress,            current_step_index=self.current_step_index,            off_route=off_route,            rerouting=False,            has_arrived=self.has_arrived        )                return state        def stop_navigation(self):        """Stop navigation"""        self.is_navigating = False        logger.info("ðŸ›‘ Navigation stopped")        def request_reroute(self, current_location: GPSLocation) -> bool:        """        Request a reroute from current location to destination                Args:            current_location: Current GPS location                    Returns:            True if reroute was successful        """        if not self.destination:            logger.error("Cannot reroute: no destination set")            return False                logger.info(f"ðŸ”„ Rerouting from {current_location.coordinates} to {self.destination.coordinates}")                try:            # Import routing service here to avoid circular imports            from backend.services.transportation_directions_service import TransportationDirectionsService                        routing_service = TransportationDirectionsService()                        # Request new route            result = routing_service.get_directions(                origin=current_location.coordinates,                destination=self.destination.coordinates,                mode='walking'  # Use current mode            )                        if result and 'routes' in result and len(result['routes']) > 0:                route = result['routes'][0]                                # Convert OSRM route to RouteSteps                new_steps = self._convert_osrm_to_steps(route)                                if new_steps:                    self.route_steps = new_steps                    self.current_step_index = 0                    logger.info(f"âœ… Reroute successful: {len(new_steps)} new steps")                    return True                        logger.error("Failed to generate reroute")            return False                    except Exception as e:            logger.error(f"Error during reroute: {e}")            return False        def _convert_osrm_to_steps(self, osrm_route: Dict[str, Any]) -> List[RouteStep]:        """        Convert OSRM route format to RouteStep list                Args:            osrm_route: Route from OSRM API                    Returns:            List of RouteStep objects        """        steps = []                if 'legs' not in osrm_route:            return steps                for leg in osrm_route['legs']:            if 'steps' not in leg:                continue                        for step_data in leg['steps']:                # Extract locations                start_coords = step_data.get('maneuver', {}).get('location', [])                end_coords = None                                # Get end coords from geometry